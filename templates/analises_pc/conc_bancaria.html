<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conciliação Bancária - Análise PC - FAF</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
<style>
    .conc-card {
        background: white;
        border-radius: 10px;
        padding: 25px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .table-conc {
        font-size: 0.9rem;
        border-collapse: collapse;
        margin-bottom: 0;
        width: 100%;
    }
    
    .table-conc thead th {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        font-weight: 600;
        padding: 12px 8px;
        border: none;
        text-align: center;
        vertical-align: middle;
    }
    
    .table-conc tbody td {
        padding: 8px;
        vertical-align: middle;
        border: 1px solid #dee2e6;
    }
    
    .table-conc tbody tr:hover {
        background-color: #f8f9fa;
    }
    
    /* Células de entrada */
    .cell-input {
        width: 100%;
        border: none;
        padding: 6px;
        text-align: center;
        background: transparent;
    }
    
    .cell-input:focus {
        outline: 2px solid #667eea;
        background: #f0f4ff;
    }
    
    /* Células monetárias */
    .cell-money {
        text-align: right;
        font-family: 'Courier New', monospace;
        font-weight: 600;
    }
    
    /* Input de competência com erro */
    .competencia-input.is-invalid {
        border-color: #dc3545;
        padding-right: calc(1.5em + 0.75rem);
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 12 12' width='12' height='12' fill='none' stroke='%23dc3545'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23dc3545' stroke='none'/%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right calc(0.375em + 0.1875rem) center;
        background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
    }
    
    .invalid-feedback {
        font-size: 0.75rem;
        color: #dc3545;
        margin-top: 0.25rem;
    }
    
    /* Células mescladas */
    .cell-merged {
        background: linear-gradient(to bottom, #fff 0%, #f0f4ff 100%);
        border-left: 3px solid #667eea !important;
        position: relative;
    }
    
    .cell-merged::before {
        content: '↕';
        position: absolute;
        left: 2px;
        top: 50%;
        transform: translateY(-50%);
        color: #667eea;
        font-size: 12px;
    }
    
    /* Botões de ação */
    .btn-action {
        padding: 4px 8px;
        font-size: 0.85rem;
    }
    
    .btn-move {
        padding: 2px 6px;
        font-size: 0.75rem;
    }
    
    /* Container com scroll */
    .table-container {
        max-height: calc(100vh - 250px);
        overflow-y: auto;
        overflow-x: auto;
        border: 1px solid #dee2e6;
        border-radius: 8px;
    }
    
    /* Botão save no menu superior */
    .btn-save-top {
        min-width: 200px;
    }
    
    /* Headers clicáveis com ícone de info */
    .tooltip-header {
        cursor: pointer;
        position: relative;
    }
    
    .tooltip-header .info-icon {
        color: #667eea;
        font-size: 0.9rem;
        margin-left: 5px;
    }
    
    .tooltip-header:hover .info-icon {
        color: #4c63d2;
    }
    
    /* Garantir que thead não cubra modais */
    .table-conc thead {
        position: relative;
        z-index: 1;
    }
    
    .table-conc thead th {
        position: relative;
        z-index: 1;
    }
    
    /* Células mescladas verticalmente */
    .cell-merged-group {
        border-left: 4px solid #667eea !important;
        background: linear-gradient(to right, #f0f4ff 0%, #fff 10%);
    }
    
    .cell-merged-first {
        border-top: 2px solid #667eea !important;
    }
    
    .cell-merged-last {
        border-bottom: 2px solid #667eea !important;
    }
    
    .merged-cell-content {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
    }
    
    .merged-indicator {
        font-size: 0.75rem;
        color: #667eea;
        margin-left: 5px;
    }
    
    /* Loading indicator */
    .loading {
        display: none;
        text-align: center;
        padding: 20px;
    }
    
    /* Cores das linhas baseado na avaliação */
    .avaliacao-avaliado td {
        background-color: #c6efce !important;
    }
    
    .avaliacao-aguardando td {
        background-color: #f2ceef !important;
    }
    
    .avaliacao-pessoa-gestora td {
        background-color: #c0e4f5 !important;
    }
    
    .avaliacao-glosar td {
        background-color: #fbe2d5 !important;
    }
    
    /* Linha de separação entre meses */
    tr.mudanca-mes {
        border-top: 4px solid #007bff !important;
    }
    
    /* Célula desabilitada - Seletor mais específico para sobrepor cores de avaliação */
    td.cell-disabled,
    .avaliacao-avaliado td.cell-disabled,
    .avaliacao-aguardando td.cell-disabled,
    .avaliacao-pessoa-gestora td.cell-disabled,
    .avaliacao-glosar td.cell-disabled {
        background-color: #e9ecef !important;
        cursor: not-allowed;
    }
    
    /* Validação de composição - composição diferente do valor */
    td.composicao-invalida input {
        background-color: #ffcccc !important;
        border: 2px solid #ff0000 !important;
    }
    
    /* Validação de CNPJ - laranja se não tiver 14 dígitos */
    td.cnpj-invalido input {
        background-color: #ffe0b3 !important;
        border: 2px solid #ff9800 !important;
    }
    
    /* Cabeçalhos das colunas de Notas Fiscais */
    .table-conc thead th.th-notas-fiscais {
        background: linear-gradient(135deg, #5a3e8c 0%, #3d2861 100%);
    }
    
    /* Cabeçalhos das colunas de Documentos */
    .table-conc thead th.th-documentos {
        background: linear-gradient(135deg, #0d6efd 0%, #0a58ca 100%);
    }
    
    /* Indicador de autosave fixo */
    #autosaveStatus {
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 1050;
        padding: 8px 15px;
        background-color: #28a745;
        color: white;
        border-radius: 5px;
        font-size: 0.85rem;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        display: none;
    }
</style>
</head>
<body>

<div class="container-fluid mt-4">
    <!-- Indicador de Performance -->
    <div id="perfIndicator" style="position: fixed; top: 10px; right: 10px; z-index: 2000; background: #2c3e50; color: white; padding: 10px 15px; border-radius: 5px; font-family: monospace; font-size: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: none;">
        <div style="font-weight: bold; margin-bottom: 5px;">⚡ Performance Monitor</div>
        <div id="perfStats"></div>
        <div style="margin-top: 8px; font-size: 10px; opacity: 0.7;">
            Console: perfSummary() | perfClear() | perfToggle()
        </div>
    </div>
    
    <div class="d-flex justify-content-between align-items-center mb-4">
        <h2><i class="bi bi-bank me-2"></i>Conciliação Bancária</h2>
        <div>
            <a href="#" class="btn btn-success me-2" id="btnRendimentos" onmousedown="atualizarHrefRendimentos()" onclick="abrirRendimentos(event)" title="Rendimentos de Ativos Financeiros">
                <i class="bi bi-piggy-bank me-2"></i>Rendimentos
            </a>
            <a href="#" class="btn btn-warning me-2" id="btnContrapartida" onmousedown="atualizarHrefContrapartida()" onclick="abrirContrapartida(event)" title="Análise da Contrapartida" style="display: none;">
                <i class="bi bi-cash-coin me-2"></i>Contrapartida
            </a>
            <a href="#" class="btn btn-primary me-2" id="btnRelatorio" onmousedown="atualizarHrefRelatorio()" onclick="abrirRelatorio(event)" title="Relatório de Conciliação">
                <i class="bi bi-file-text me-2"></i>Relatório
            </a>
            <a href="/ocr_testes/" class="btn btn-info me-2" id="btnOCR" onmousedown="atualizarHrefOCR()" onclick="abrirOCR(event)" title="OCR - Conversão de Extrato">
                <i class="bi bi-file-earmark-text me-2"></i>OCR (testes)
            </a>
            <button class="btn btn-outline-secondary btn-sm me-2" onclick="togglePerfMonitor()" title="Toggle Performance Monitor">
                <i class="bi bi-speedometer2"></i>
            </button>
            <button class="btn btn-outline-primary me-2" id="btnMenuSecoes" onclick="toggleMenuSecoes()">
                <i class="bi bi-list-check me-2"></i>Seções
            </button>
            <button class="btn btn-outline-warning me-2" id="btnUndo" onclick="desfazerAlteracao()" style="display: none;">
                <i class="bi bi-arrow-counterclockwise me-1"></i>Desfazer
            </button>
            <div class="btn-group me-2">
                <button class="btn btn-outline-primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                    <i class="bi bi-pencil-square me-1"></i>Adicionar ou Excluir Linhas
                </button>
                <ul class="dropdown-menu p-3" style="min-width: 320px;">
                    <!-- Adicionar Linhas -->
                    <li>
                        <h6 class="dropdown-header text-primary"><i class="bi bi-plus-circle"></i> Adicionar Linhas</h6>
                    </li>
                    <li class="px-2 mb-3">
                        <div class="input-group input-group-sm">
                            <input type="number" 
                                   class="form-control" 
                                   id="inputAdicionarLinhas" 
                                   placeholder="Quantidade"
                                   min="1"
                                   value="1">
                            <button class="btn btn-primary" onclick="adicionarLinhasEmLote()">
                                <i class="bi bi-plus-lg me-1"></i>Adicionar
                            </button>
                        </div>
                        <small class="text-muted d-block mt-1">Adiciona linhas vazias no final</small>
                    </li>
                    
                    <li><hr class="dropdown-divider"></li>
                    
                    <!-- Excluir Linhas -->
                    <li>
                        <h6 class="dropdown-header text-danger"><i class="bi bi-trash"></i> Excluir Linhas</h6>
                    </li>
                    <li class="px-2">
                        <div class="input-group input-group-sm">
                            <input type="text" 
                                   class="form-control" 
                                   id="inputExcluirLinhas" 
                                   placeholder="Ex: 114-120 ou 5,10,15">
                            <button class="btn btn-danger" onclick="excluirLinhasPorIntervalo()">
                                <i class="bi bi-trash me-1"></i>Excluir
                            </button>
                        </div>
                        <small class="text-muted d-block mt-1">Use intervalos (1-5) ou índices (2,4,6)</small>
                    </li>
                </ul>
            </div>
            <button class="btn btn-success me-2" onclick="exportarCSV()">
                <i class="bi bi-download me-2"></i>Exportar CSV
            </button>
            <button class="btn btn-danger me-2" onclick="abrirModalPDF()" data-bs-toggle="modal" data-bs-target="#modalExportarPDF">
                <i class="bi bi-file-pdf me-2"></i>Exportar PDF
            </button>
            <button class="btn btn-info me-2" onclick="baixarModelo()">
                <i class="bi bi-file-earmark-arrow-down me-2"></i>Modelo Importação
            </button>
            <button class="btn btn-outline-danger me-2" onclick="limparTabela()">
                <i class="bi bi-trash me-2"></i>Limpar
            </button>
            <a href="/analises_pc" class="btn btn-outline-secondary me-2">
                <i class="bi bi-arrow-left me-2"></i>Voltar
            </a>
            <button class="btn btn-warning" id="btnAtualizarGuias" onclick="atualizarGuiasAutomaticamente()" style="display: none;" title="Atualizar Guias e preencher Competências automaticamente">
                <i class="bi bi-magic me-2"></i>Auto-preencher Guias e Competências
            </button>
        </div>
    </div>

    <!-- Seleção de Termo -->
    <div class="conc-card">
        <div class="row g-3 align-items-end">
            <div class="col-md-3">
                <label for="numeroTermo" class="form-label"><strong>Número do Termo</strong></label>
                <input type="text" 
                       class="form-control" 
                       id="numeroTermo" 
                       list="datalistTermos"
                       placeholder="Digite para buscar..."
                       onchange="carregarExtrato()"
                       oninput="filtrarTermos(this.value)">
                <datalist id="datalistTermos">
                </datalist>
            </div>
            <div class="col-md-3">
                <label for="bancoExtrato" class="form-label"><strong>Banco do Extrato</strong></label>
                <select class="form-select" id="bancoExtrato">
                    <option value="">Selecione o banco...</option>
                    <option value="Banco do Brasil">Banco do Brasil</option>
                    <option value="Itaú Unibanco">Itaú Unibanco</option>
                    <option value="Bradesco">Bradesco</option>
                    <option value="Caixa Econômica Federal">Caixa Econômica Federal</option>
                    <option value="Santander">Santander</option>
                </select>
            </div>
            <div class="col-md-2">
                <label class="form-label"><strong>Visualização</strong></label>
                <select class="form-select" id="selectModoVisualizacao" onchange="mudarModoVisualizacao()">
                    <option value="paginas">Por Mês (Páginas)</option>
                    <option value="todas">Todas as Linhas</option>
                </select>
            </div>
            <div class="col-md-3" id="divNavegacaoMes" style="display: block;">
                <label class="form-label"><strong>Selecionar Mês(es)</strong></label>
                <select class="form-select" id="selectMesVisualizacao" onchange="mudarMesSelecionado()">
                    <option value="">Selecione um mês...</option>
                </select>
            </div>
            <div class="col-md-1">
                <button class="btn btn-outline-info w-100" onclick="toggleFiltros()" id="btnToggleFiltros">
                    <i class="bi bi-funnel me-1"></i>Filtros
                </button>
            </div>
            <div class="col-md-1">
                <button class="btn btn-primary w-100 btn-save-top" onclick="salvarConciliacao()" id="btnSalvar" style="display: none;">
                    <i class="bi bi-save me-2"></i>Salvar
                </button>
            </div>
            <div class="col-md-1">
                <button class="btn btn-outline-secondary w-100" onclick="irParaUltimaLinha()" title="Ir para a última linha">
                    <i class="bi bi-arrow-down-circle"></i>
                </button>
            </div>
            <div class="col-md-1">
                <button class="btn btn-outline-secondary w-100" onclick="renderizarTabela()" title="Atualizar visualização">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Menu de Seções -->
    <div class="conc-card" id="menuSecoes" style="display: none;">
        <h5 class="mb-3"><i class="bi bi-list-check me-2"></i>Seções Disponíveis</h5>
        <div class="row g-3">
            <div class="col-md-6">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="secaoExtrato" checked disabled>
                    <label class="form-check-label" for="secaoExtrato">
                        <strong>1. Conciliação do Extrato</strong> (10 colunas) - Sempre visível
                    </label>
                </div>
            </div>
            <div class="col-md-6">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="secaoNotasFiscais" onchange="toggleSecaoNotasFiscais()">
                    <label class="form-check-label" for="secaoNotasFiscais">
                        <strong>2. Notas Fiscais</strong> (3 colunas) - Número, Chave de Acesso, CNPJ
                    </label>
                </div>
            </div>
            <div class="col-md-6">
                <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="secaoDocumentos" onchange="toggleSecaoDocumentos()">
                    <label class="form-check-label" for="secaoDocumentos">
                        <strong>3. Documentos a serem avaliados</strong> (4 colunas) - Guia, Comprovante, Contratos, Fora Município
                    </label>
                </div>
            </div>
        </div>
    </div>

    <!-- Filtros Avançados -->
    <div class="conc-card" id="filtrosAvancados" style="display: none;">
        <div class="row g-3">
            <div class="col-md-2">
                <label for="filtroData" class="form-label"><strong><i class="bi bi-funnel me-1"></i>Filtrar por Data (Mês/Ano)</strong></label>
                <select class="form-select" id="filtroData" multiple size="4" onchange="aplicarFiltros()">
                    <option value="">Todas as datas</option>
                    <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                </select>
                <small class="text-muted">Ctrl+Click para múltipla seleção</small>
            </div>
            <div class="col-md-2">
                <label for="filtroCompetencia" class="form-label"><strong><i class="bi bi-funnel me-1"></i>Filtrar por Competência</strong></label>
                <select class="form-select" id="filtroCompetencia" multiple size="4" onchange="aplicarFiltros()">
                    <option value="">Todas as competências</option>
                    <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                </select>
                <small class="text-muted">Ctrl+Click para múltipla seleção</small>
            </div>
            <div class="col-md-3">
                <label for="filtroCategoria" class="form-label"><strong><i class="bi bi-funnel me-1"></i>Filtrar por Categoria</strong></label>
                <select class="form-select" id="filtroCategoria" multiple size="4" onchange="aplicarFiltros()">
                    <option value="">Todas as categorias</option>
                    <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                </select>
                <small class="text-muted">Ctrl+Click para múltipla seleção</small>
            </div>
            <div class="col-md-2">
                <label for="filtroOrigemDestino" class="form-label"><strong><i class="bi bi-funnel me-1"></i>Filtrar por Origem/Destino</strong></label>
                <select class="form-select" id="filtroOrigemDestino" multiple size="4" onchange="aplicarFiltros()">
                    <option value="">Todas as origens/destinos</option>
                    <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                </select>
                <small class="text-muted">Ctrl+Click para múltipla seleção</small>
            </div>
            <div class="col-md-2">
                <label for="filtroAvaliacao" class="form-label"><strong><i class="bi bi-funnel me-1"></i>Filtrar por Avaliação</strong></label>
                <select class="form-select" id="filtroAvaliacao" multiple size="4" onchange="aplicarFiltros()">
                    <option value="">Todas as avaliações</option>
                    <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                    <option value="Avaliado">Avaliado</option>
                    <option value="Aguardando resposta">Aguardando resposta</option>
                    <option value="Pessoa Gestora">Pessoa Gestora</option>
                    <option value="Glosar">Glosar</option>
                </select>
                <small class="text-muted">Ctrl+Click para múltipla seleção</small>
            </div>
            <div class="col-md-2">
                <label for="filtroObservacoes" class="form-label"><strong><i class="bi bi-funnel me-1"></i>Filtrar por Observações</strong></label>
                <select class="form-select" id="filtroObservacoes" multiple size="4" onchange="aplicarFiltros()">
                    <option value="">Todas</option>
                    <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                    <option value="__PREENCHIDO__" style="color: #28a745; font-style: italic;">✅ Preenchido</option>
                </select>
                <small class="text-muted">Ctrl+Click para múltipla seleção</small>
            </div>
            <div class="col-md-1 d-flex flex-column justify-content-end">
                <button class="btn btn-secondary mb-2" onclick="limparFiltros()">
                    <i class="bi bi-x-circle me-1"></i>Limpar
                </button>
                <button class="btn btn-outline-primary" onclick="expandirFiltros()" title="Expandir filtros">
                    <i class="bi bi-arrows-angle-expand"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Loading -->
    <div class="loading" id="loadingIndicator">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Carregando...</span>
        </div>
        <p class="mt-2">Carregando dados...</p>
    </div>

    <!-- Tabela de Conciliação -->
    <div class="conc-card">
        <div class="table-container">
            <table class="table table-conc table-sm" id="tabelaConciliacao">
                <thead>
                    <tr>
                        <th style="width: 60px;" class="tooltip-header" onclick="mostrarInfo('indice')">
                            1. Índice <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 140px;" class="tooltip-header" onclick="mostrarInfo('data')">
                            2. Data <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 140px;" class="tooltip-header" onclick="mostrarInfo('credito')">
                            3. Crédito (R$) <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 140px;" class="tooltip-header" onclick="mostrarInfo('debito')">
                            4. Débito (R$) <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 150px;" class="tooltip-header" onclick="mostrarInfo('composicao')">
                            5. Composição do Valor (R$) <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 260px;" class="tooltip-header" onclick="mostrarInfo('categoria')">
                            6. Categoria de Transação <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 130px;" class="tooltip-header" onclick="mostrarInfo('competencia')">
                            7. Competência <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 240px;" class="tooltip-header" onclick="mostrarInfo('origem_destino')">
                            8. Origem ou Destino <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 180px;" class="tooltip-header" onclick="mostrarInfo('avaliacao')">
                            9. Avaliação <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 250px;" class="tooltip-header" onclick="mostrarInfo('observacoes')">
                            10. Observações <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 180px;">Ações</th>
                        <!-- Colunas de Notas Fiscais (Seção 2) -->
                        <th style="width: 150px; display: none;" class="th-notas-fiscais col-nf" id="thNumeroNota">
                            11. Número da Nota
                        </th>
                        <th style="width: 250px; display: none;" class="th-notas-fiscais col-nf" id="thChaveAcesso">
                            12. Chave de Acesso
                        </th>
                        <th style="width: 180px; display: none;" class="th-notas-fiscais col-nf" id="thCnpjNota">
                            13. CNPJ
                        </th>
                        <!-- Colunas de Documentos (Seção 3) -->
                        <th style="width: 100px; display: none;" class="th-documentos col-doc tooltip-header" id="thGuia" onclick="mostrarInfo('guia')">
                            14. Guia <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 150px; display: none;" class="th-documentos col-doc tooltip-header" id="thComprovante" onclick="mostrarInfo('comprovante')">
                            15. Comprovante <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 120px; display: none;" class="th-documentos col-doc tooltip-header" id="thContratos" onclick="mostrarInfo('contratos')">
                            16. Contratos <i class="bi bi-info-circle info-icon"></i>
                        </th>
                        <th style="width: 150px; display: none;" class="th-documentos col-doc tooltip-header" id="thForaMunicipio" onclick="mostrarInfo('fora_municipio')">
                            17. Fora Município <i class="bi bi-info-circle info-icon"></i>
                        </th>
                    </tr>
                </thead>
                <tbody id="tbodyConciliacao">
                    <!-- Linhas serão inseridas via JavaScript -->
                </tbody>
            </table>
        </div>
    </div>
</div>

<!-- Datalist para Origem/Destino (auto-alimentado) -->
<datalist id="datalistOrigemDestino">
</datalist>

<!-- Datalist para Observações -->
<datalist id="datalistObservacoes">
</datalist>

<!-- Datalist para Competência -->
<datalist id="datalistCompetencia">
    <option value="Sem competência">Sem competência</option>
</datalist>

<!-- Datalist para Avaliações -->
<datalist id="datalistAvaliacoes">
    <option value="Avaliado">Avaliado</option>
    <option value="Aguardando resposta">Aguardando resposta</option>
    <option value="Pessoa Gestora">Pessoa Gestora</option>
    <option value="Glosar">Glosar</option>
</datalist>

<!-- Modal de Informação -->
<div class="modal fade" id="modalInfo" tabindex="-1" aria-labelledby="modalInfoLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="modalInfoLabel">
                    <i class="bi bi-info-circle me-2"></i>Informação
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fechar"></button>
            </div>
            <div class="modal-body" id="modalInfoBody">
                <!-- Conteúdo será inserido via JavaScript -->
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal de Exportação PDF -->
<div class="modal fade" id="modalExportarPDF" tabindex="-1" aria-labelledby="modalExportarPDFLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header bg-danger text-white">
                <h5 class="modal-title" id="modalExportarPDFLabel">
                    <i class="bi bi-file-pdf me-2"></i>Exportar para PDF
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fechar"></button>
            </div>
            <div class="modal-body">
                <p class="mb-3"><strong>Selecione as colunas que deseja incluir na exportação:</strong></p>
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="indice" id="checkIndice" checked>
                            <label class="form-check-label" for="checkIndice">1. Índice</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="data" id="checkData" checked>
                            <label class="form-check-label" for="checkData">2. Data</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="credito" id="checkCredito" checked>
                            <label class="form-check-label" for="checkCredito">3. Crédito (R$)</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="debito" id="checkDebito" checked>
                            <label class="form-check-label" for="checkDebito">4. Débito (R$)</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="discriminacao" id="checkDiscriminacao" checked>
                            <label class="form-check-label" for="checkDiscriminacao">5. Composição do Valor (R$)</label>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="cat_transacao" id="checkCategoria" checked>
                            <label class="form-check-label" for="checkCategoria">6. Categoria de Transação</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="competencia" id="checkCompetencia" checked>
                            <label class="form-check-label" for="checkCompetencia">7. Competência</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="origem_destino" id="checkOrigemDestino" checked>
                            <label class="form-check-label" for="checkOrigemDestino">8. Origem ou Destino</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="cat_avaliacao" id="checkAvaliacao" checked>
                            <label class="form-check-label" for="checkAvaliacao">9. Avaliação</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="avaliacao_analista" id="checkObservacoes" checked>
                            <label class="form-check-label" for="checkObservacoes">10. Observações</label>
                        </div>
                    </div>
                </div>
                <hr>
                <div class="d-flex justify-content-between">
                    <button type="button" class="btn btn-sm btn-outline-primary" onclick="selecionarTodasColunas()">
                        <i class="bi bi-check-all me-1"></i>Selecionar Todas
                    </button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" onclick="desmarcarTodasColunas()">
                        <i class="bi bi-x-circle me-1"></i>Desmarcar Todas
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-danger" onclick="exportarPDF()">
                    <i class="bi bi-file-pdf me-2"></i>Gerar PDF
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Modal de Filtros Expandidos -->
<div class="modal fade" id="modalFiltrosExpandidos" tabindex="-1" aria-labelledby="modalFiltrosExpandidosLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title" id="modalFiltrosExpandidosLabel">
                    <i class="bi bi-funnel me-2"></i>Filtros Avançados - Visualização Expandida
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Fechar"></button>
            </div>
            <div class="modal-body">
                <div class="row g-4">
                    <!-- Seção 1: Filtros principais (Categoria, Origem/Destino, Avaliação) -->
                    <div class="col-md-4">
                        <label for="filtroCategoriaExpandido" class="form-label fw-bold"><i class="bi bi-tags me-1"></i>Categoria</label>
                        <select class="form-select" id="filtroCategoriaExpandido" multiple size="12" onchange="sincronizarFiltro('filtroCategoria', 'filtroCategoriaExpandido')">
                            <option value="">Todas as categorias</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="filtroOrigemDestinoExpandido" class="form-label fw-bold"><i class="bi bi-arrow-left-right me-1"></i>Origem/Destino</label>
                        <select class="form-select" id="filtroOrigemDestinoExpandido" multiple size="12" onchange="sincronizarFiltro('filtroOrigemDestino', 'filtroOrigemDestinoExpandido')">
                            <option value="">Todas as origens/destinos</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="filtroAvaliacaoExpandido" class="form-label fw-bold"><i class="bi bi-clipboard-check me-1"></i>Avaliação</label>
                        <select class="form-select" id="filtroAvaliacaoExpandido" multiple size="12" onchange="sincronizarFiltro('filtroAvaliacao', 'filtroAvaliacaoExpandido')">
                            <option value="">Todas as avaliações</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                            <option value="Avaliado">Avaliado</option>
                            <option value="Aguardando resposta">Aguardando resposta</option>
                            <option value="Pessoa Gestora">Pessoa Gestora</option>
                            <option value="Glosar">Glosar</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="filtroObservacoesExpandido" class="form-label fw-bold"><i class="bi bi-chat-left-text me-1"></i>Observações</label>
                        <select class="form-select" id="filtroObservacoesExpandido" multiple size="12" onchange="sincronizarFiltro('filtroObservacoes', 'filtroObservacoesExpandido')">
                            <option value="">Todas</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                            <option value="__PREENCHIDO__" style="color: #28a745; font-style: italic;">✅ Preenchido</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="filtroGuiaExpandido" class="form-label fw-bold"><i class="bi bi-file-earmark-text me-1"></i>Guia</label>
                        <select class="form-select" id="filtroGuiaExpandido" multiple size="12" onchange="sincronizarFiltro('filtroGuia', 'filtroGuiaExpandido')">
                            <option value="">Todas</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                            <option value="Guia apresentada">Guia apresentada</option>
                            <option value="Guia apresentada (cliente divergente)">Guia apresentada (cliente divergente)</option>
                            <option value="Guia apresentada (destinatário não identificado)">Guia apresentada (destinatário não identificado)</option>
                            <option value="Não apresentada">Não apresentada</option>
                        </select>
                    </div>
                    <div class="col-md-4">
                        <label for="filtroComprovanteExpandido" class="form-label fw-bold"><i class="bi bi-receipt me-1"></i>Comprovante</label>
                        <select class="form-select" id="filtroComprovanteExpandido" multiple size="12" onchange="sincronizarFiltro('filtroComprovante', 'filtroComprovanteExpandido')">
                            <option value="">Todas</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                            <option value="Apresentado corretamente">Apresentado corretamente</option>
                            <option value="Cartão de Crédito">Cartão de Crédito</option>
                            <option value="Pago em Espécie">Pago em Espécie</option>
                            <option value="Pago em Cheque">Pago em Cheque</option>
                        </select>
                    </div>
                </div>
                <div class="row g-4 mt-1">
                    <div class="col-md-6">
                        <label for="filtroContratosExpandido" class="form-label fw-bold"><i class="bi bi-file-earmark-ruled me-1"></i>Contratos</label>
                        <select class="form-select" id="filtroContratosExpandido" multiple size="8" onchange="sincronizarFiltro('filtroContratos', 'filtroContratosExpandido')">
                            <option value="">Todas</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                            <option value="Contratos apresentados">Contratos apresentados</option>
                            <option value="Não apresentado">Não apresentado</option>
                        </select>
                    </div>
                    <div class="col-md-6">
                        <label for="filtroForaMunicipioExpandido" class="form-label fw-bold"><i class="bi bi-geo-alt me-1"></i>Fora Município</label>
                        <select class="form-select" id="filtroForaMunicipioExpandido" multiple size="8" onchange="sincronizarFiltro('filtroForaMunicipio', 'filtroForaMunicipioExpandido')">
                            <option value="">Todas</option>
                            <option value="__NAO_PREENCHIDO__" style="color: #dc3545; font-style: italic;">❌ Não preenchido</option>
                            <option value="São Paulo">São Paulo</option>
                            <option value="Fora do município">Fora do município</option>
                        </select>
                    </div>
                </div>
                <hr>
                <!-- Seção de Seleção de Meses (Checkboxes) -->
                <div class="row g-4 mt-1">
                    <div class="col-12">
                        <label class="form-label fw-bold"><i class="bi bi-calendar3 me-1"></i>Filtrar por Mês(es) da Data</label>
                        <div class="alert alert-info py-2" style="font-size: 0.875rem;">
                            <i class="bi bi-info-circle me-1"></i>Selecione os meses que deseja visualizar. Você pode marcar múltiplos meses para ver dados de períodos diferentes simultaneamente.
                        </div>
                        <div class="d-flex justify-content-between mb-2">
                            <button type="button" class="btn btn-sm btn-outline-primary" onclick="selecionarTodosMeses()">
                                <i class="bi bi-check-all me-1"></i>Selecionar Todos
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="desmarcarTodosMeses()">
                                <i class="bi bi-x-circle me-1"></i>Desmarcar Todos
                            </button>
                        </div>
                        <div id="checkboxesMeses" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px; padding: 15px; background-color: #f8f9fa;">
                            <!-- Checkboxes serão adicionados dinamicamente aqui -->
                        </div>
                    </div>
                </div>
                <hr>
                <p class="text-muted mb-0"><small><i class="bi bi-info-circle me-1"></i>Use Ctrl+Click para selecionar múltiplos itens. As seleções são sincronizadas automaticamente.</small></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" onclick="limparFiltrosExpandidos()">
                    <i class="bi bi-x-circle me-2"></i>Limpar Todos
                </button>
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">
                    <i class="bi bi-check-circle me-2"></i>Aplicar e Fechar
                </button>
            </div>
        </div>
    </div>
</div>

<script>
    let linhas = [];
    let notasFiscais = {}; // Objeto indexado por conc_extrato_id
    let documentosAnalise = {}; // Objeto indexado por conc_extrato_id
    let categoriasAplicabilidade = {}; // Dicionário { categoria: aplicacao (true/false) }
    let categoriasRubricas = {}; // Dicionário { categoria: rubrica }
    let secaoNotasFiscaisAtiva = false;
    let secaoDocumentosAtiva = false;
    let limiteAtual = 100;
    let modoVisualizacao = 'paginas'; // 'paginas' ou 'todas'
    let mesesDisponiveis = []; // Lista de meses disponíveis (MM/AAAA)
    let mesesSelecionados = []; // Meses selecionados via checkboxes
    let mesAtualIndex = 0; // Índice do mês atual na lista (não usado mais com checkboxes)
    let proximoIndice = 1;
    let historicoAlteracoes = []; // Histórico para Undo (máximo 20 estados)
    const MAX_HISTORICO = 20;
    
    // ============================================================
    // SISTEMA DE PROFILING DE PERFORMANCE
    // ============================================================
    const performanceMetrics = {
        enabled: true, // Ativar/desativar profiling
        logs: [],
        
        start(label) {
            if (!this.enabled) return;
            return {
                label: label,
                startTime: performance.now()
            };
        },
        
        end(timer) {
            if (!this.enabled || !timer) return;
            const duration = performance.now() - timer.startTime;
            const log = {
                label: timer.label,
                duration: duration.toFixed(2),
                timestamp: new Date().toISOString()
            };
            this.logs.push(log);
            
            // Log colorido no console
            const color = duration > 1000 ? 'color: red; font-weight: bold' : 
                         duration > 500 ? 'color: orange' : 
                         duration > 100 ? 'color: blue' : 'color: green';
            console.log(`%c[PERF] ${timer.label}: ${duration.toFixed(2)}ms`, color);
            
            return duration;
        },
        
        summary() {
            console.log('\n========== PERFORMANCE SUMMARY ==========');
            const grouped = {};
            this.logs.forEach(log => {
                if (!grouped[log.label]) {
                    grouped[log.label] = { count: 0, total: 0, min: Infinity, max: -Infinity };
                }
                const dur = parseFloat(log.duration);
                grouped[log.label].count++;
                grouped[log.label].total += dur;
                grouped[log.label].min = Math.min(grouped[log.label].min, dur);
                grouped[log.label].max = Math.max(grouped[log.label].max, dur);
            });
            
            Object.entries(grouped).forEach(([label, stats]) => {
                const avg = stats.total / stats.count;
                console.log(`${label}:`);
                console.log(`  Calls: ${stats.count} | Total: ${stats.total.toFixed(2)}ms | Avg: ${avg.toFixed(2)}ms | Min: ${stats.min.toFixed(2)}ms | Max: ${stats.max.toFixed(2)}ms`);
            });
            console.log('=========================================\n');
        },
        
        clear() {
            this.logs = [];
            console.log('[PERF] Metrics cleared');
        }
    };
    
    // Comando global para análise
    window.perfSummary = () => performanceMetrics.summary();
    window.perfClear = () => performanceMetrics.clear();
    window.perfToggle = () => {
        performanceMetrics.enabled = !performanceMetrics.enabled;
        console.log(`[PERF] Profiling ${performanceMetrics.enabled ? 'ENABLED' : 'DISABLED'}`);
    };
    
    // Função para toggle do monitor visual
    function togglePerfMonitor() {
        const monitor = document.getElementById('perfIndicator');
        if (monitor.style.display === 'none') {
            monitor.style.display = 'block';
            updatePerfMonitor();
        } else {
            monitor.style.display = 'none';
        }
    }
    
    // Atualizar estatísticas no monitor visual
    function updatePerfMonitor() {
        const stats = document.getElementById('perfStats');
        if (!stats || !performanceMetrics.enabled) return;
        
        const grouped = {};
        performanceMetrics.logs.slice(-10).forEach(log => {
            if (!grouped[log.label]) {
                grouped[log.label] = { count: 0, total: 0, last: 0 };
            }
            const dur = parseFloat(log.duration);
            grouped[log.label].count++;
            grouped[log.label].total += dur;
            grouped[log.label].last = dur;
        });
        
        let html = '';
        Object.entries(grouped).forEach(([label, data]) => {
            const color = data.last > 1000 ? '#e74c3c' : data.last > 500 ? '#f39c12' : data.last > 100 ? '#3498db' : '#2ecc71';
            html += `<div style="margin: 3px 0; font-size: 11px;">
                <span style="color: ${color};">●</span> ${label.replace('renderizarTabela - ', '').replace('carregarExtrato - ', '')}: 
                <strong style="color: ${color};">${data.last.toFixed(0)}ms</strong>
            </div>`;
        });
        
        stats.innerHTML = html || '<div style="opacity: 0.5;">Aguardando métricas...</div>';
    }
    
    // Atualizar monitor a cada segundo quando visível
    setInterval(() => {
        const monitor = document.getElementById('perfIndicator');
        if (monitor && monitor.style.display !== 'none') {
            updatePerfMonitor();
        }
    }, 1000);
    
    // Textos informativos
    const infos = {
        'indice': 'Número sequencial que define a ordem dos lançamentos. Garante ordenação correta mesmo com inserções posteriores.',
        'data': 'Data da movimentação conforme consta no extrato bancário.',
        'credito': 'Valores positivos de entrada na conta. Somente valores de crédito no extrato. Se preencher este campo, o campo Débito será bloqueado.',
        'debito': 'Valores negativos de saída da conta. Somente valores de débito no extrato. Se preencher este campo, o campo Crédito será bloqueado.',
        'composicao': 'Valores que compõem o crédito ou débito. Útil quando uma movimentação é composta por múltiplas transações. Para mesclar valores iguais consecutivos, use o botão de mesclagem.',
        'categoria': 'Categoria da transação baseada nas despesas do termo e nas categorias de análise. As opções são filtradas automaticamente de acordo com o tipo de movimentação (crédito ou débito).',
        'competencia': 'Mês e ano da competência da transação (formato: mai/2025). É preenchida automaticamente com base na data do lançamento. Deve estar dentro do período do projeto com tolerância de 2 meses antes do início e 6 meses após o término.',
        'origem_destino': 'Origem do crédito (de onde veio o recurso) ou destino do débito (para onde foi o pagamento). Campo de texto livre para descrever a contraparte da transação.',
        'avaliacao': 'Status da avaliação da transação. Avaliado (verde) = aprovado, Aguardando resposta (rosa) = pendente, Pessoa Gestora (azul) = responsabilidade da PG, Glosar (laranja) = reprovar. A cor se aplica à linha inteira. Transações com Banco do Brasil ou Administração Pública são automaticamente avaliadas.',
        'observacoes': 'Campo livre para anotações e observações do analista sobre a transação. Útil para registrar informações adicionais, justificativas ou pendências relacionadas à análise.'
    };
    
    // Textos informativos das colunas de documentos
    const infosDocumentos = {
        'guia': 'Holerites, notas fiscais, cupons fiscais, recibos ou demonstrativos que contenham informações como: categoria de despesa, competência e prestador / fornecedor.',
        'comprovante': 'Comprovações bancárias ou possibilidade de identificação do destinatário de forma legível em extrato bancário da conta corrente.',
        'contratos': 'Contratos dos prestadores de serviço ou locação do imóvel, se houver.',
        'fora_municipio': 'Se a contratação do prestador ou houve obtenções de fornecedores que não estão no município de São Paulo, sem justificativa.'
    };
    
    let categoriasDespesas = [];
    let categoriasAnalise = [];
    let periodoTermo = { inicio: null, final: null }; // Período do projeto
    let bancoAtual = ''; // Banco do extrato
    let origensDestinosUnicos = new Set(); // Lista dinâmica de origens/destinos já utilizados
    let observacoesUnicas = new Set(); // Lista dinâmica de observações já utilizadas
    
    // OTIMIZAÇÃO: WeakMap cache para grupos de composição (memoização global)
    const gruposComposicaoCache = new WeakMap();
    
    // Regras de avaliação automática (editável)
    const regrasAvaliacao = {
        // Categorias que devem ser automaticamente marcadas como "Glosar" (prioridade máxima)
        glosar: [
            'Taxas Bancárias'
            // Adicione outras categorias aqui que devem ser glosadas automaticamente
            // Exemplo: 'Multas', 'Juros de Atraso'
        ],
        // Origens/Destinos que devem ser automaticamente marcados como "Avaliado" (prioridade baixa)
        avaliado: [
            'banco do brasil',
            'administração pública',
            'administração publica'
        ]
    };
    
    // Autosave no cache (localStorage)
    let autosaveTimer = null;
    
    function salvarNoCache() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) return;
        
        const cacheKey = `autosave_conc_${numeroTermo}`;
        const dataToSave = {
            timestamp: Date.now(),
            linhas: linhas
        };
        
        try {
            localStorage.setItem(cacheKey, JSON.stringify(dataToSave));
            console.log('✓ Autosave realizado');
            
            // Mostrar indicador visual
            const status = document.getElementById('autosaveStatus');
            if (status) {
                status.style.display = 'block';
                status.textContent = '💾 Salvo em cache';
                setTimeout(() => {
                    status.style.display = 'none';
                }, 2000);
            }
        } catch (error) {
            console.error('Erro ao salvar cache:', error);
        }
    }
    
    function limparCache() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) return;
        
        const cacheKey = `autosave_conc_${numeroTermo}`;
        localStorage.removeItem(cacheKey);
        console.log('Cache limpo');
    }
    
    function agendarAutosave() {
        // Cancelar timer anterior
        if (autosaveTimer) {
            clearTimeout(autosaveTimer);
        }
        
        // Agendar novo autosave para 3 segundos após última alteração
        autosaveTimer = setTimeout(() => {
            salvarNoCache();
        }, 3000);
    }
    
    function toggleFiltros() {
        const filtros = document.getElementById('filtrosAvancados');
        const btn = document.getElementById('btnToggleFiltros');
        
        if (filtros.style.display === 'none') {
            filtros.style.display = 'block';
            btn.classList.remove('btn-outline-info');
            btn.classList.add('btn-info');
        } else {
            filtros.style.display = 'none';
            btn.classList.remove('btn-info');
            btn.classList.add('btn-outline-info');
        }
    }
    
    function toggleMenuSecoes() {
        const menu = document.getElementById('menuSecoes');
        const btn = document.getElementById('btnMenuSecoes');
        
        if (menu.style.display === 'none') {
            menu.style.display = 'block';
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-primary');
        } else {
            menu.style.display = 'none';
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-outline-primary');
        }
    }
    
    async function toggleSecaoNotasFiscais() {
        const checkbox = document.getElementById('secaoNotasFiscais');
        secaoNotasFiscaisAtiva = checkbox.checked;
        
        // Mostrar/ocultar colunas de notas fiscais
        const colunasNF = document.querySelectorAll('.col-nf');
        colunasNF.forEach(col => {
            col.style.display = secaoNotasFiscaisAtiva ? '' : 'none';
        });
        
        // Carregar dados apenas ao ativar a seção
        if (secaoNotasFiscaisAtiva) {
            await carregarNotasFiscais();
        }
        
        // Re-renderizar tabela com skip de filtros (debounce)
        renderizarTabela(true);
    }
    
    async function toggleSecaoDocumentos() {
        const checkbox = document.getElementById('secaoDocumentos');
        secaoDocumentosAtiva = checkbox.checked;
        
        // Mostrar/ocultar colunas de documentos
        const colunasDoc = document.querySelectorAll('.col-doc');
        colunasDoc.forEach(col => {
            col.style.display = secaoDocumentosAtiva ? '' : 'none';
        });
        
        // Mostrar/ocultar botão de atualizar guias
        const btnAtualizarGuias = document.getElementById('btnAtualizarGuias');
        if (btnAtualizarGuias) {
            btnAtualizarGuias.style.display = secaoDocumentosAtiva ? 'block' : 'none';
        }
        
        // Carregar dados apenas ao ativar a seção
        if (secaoDocumentosAtiva) {
            await carregarDocumentosAnalise();
        }
        
        // Re-renderizar tabela com skip de filtros (debounce)
        renderizarTabela(true);
    }
    
    function mostrarInfo(campo) {
        const modalBody = document.getElementById('modalInfoBody');
        const texto = infos[campo] || infosDocumentos[campo] || 'Informação não disponível.';
        modalBody.innerHTML = `<p class="mb-0">${texto}</p>`;
        
        const modal = new bootstrap.Modal(document.getElementById('modalInfo'));
        modal.show();
    }

    // Carregar termos ao iniciar
    document.addEventListener('DOMContentLoaded', function() {
        // Mostrar instruções de performance no console
        console.log('%c🚀 SISTEMA DE PROFILING DE PERFORMANCE ATIVADO', 'color: #2ecc71; font-size: 14px; font-weight: bold;');
        console.log('%cComandos disponíveis no console:', 'color: #3498db; font-weight: bold;');
        console.log('%c  perfSummary()  %c- Mostrar resumo de todas as métricas coletadas', 'color: #e74c3c; font-weight: bold;', 'color: #95a5a6;');
        console.log('%c  perfClear()    %c- Limpar histórico de métricas', 'color: #e74c3c; font-weight: bold;', 'color: #95a5a6;');
        console.log('%c  perfToggle()   %c- Ativar/desativar coleta de métricas', 'color: #e74c3c; font-weight: bold;', 'color: #95a5a6;');
        console.log('%cMonitor visual:', 'color: #3498db; font-weight: bold;');
        console.log('%c  Clique no botão ⚡ no canto superior direito', 'color: #95a5a6;');
        console.log('');
        
        carregarTermos();
    });

    let todosOsTermos = []; // Lista completa de termos

    async function carregarTermos() {
        try {
            console.log('Carregando termos...');
            const response = await fetch('/conc_bancaria/api/termos');
            if (!response.ok) throw new Error('Erro ao carregar termos');
            
            todosOsTermos = await response.json();
            console.log('Termos recebidos:', todosOsTermos);
            
            // Popular datalist inicialmente com todos os termos
            atualizarDatalistTermos(todosOsTermos);
            
            // Verificar se há termo na URL (vindo da página de análises)
            const urlParams = new URLSearchParams(window.location.search);
            const termoUrl = urlParams.get('termo');
            console.log('Termo da URL:', termoUrl);
            
            if (termoUrl) {
                // Se termo não está na lista, adicionar (novo termo)
                if (!todosOsTermos.includes(termoUrl)) {
                    console.log('Termo novo, adicionando à lista:', termoUrl);
                    todosOsTermos.push(termoUrl);
                    atualizarDatalistTermos(todosOsTermos);
                }
                
                // Selecionar e carregar (funciona para novos e existentes)
                console.log('Selecionando termo:', termoUrl);
                document.getElementById('numeroTermo').value = termoUrl;
                await carregarExtrato();
            }
            
        } catch (error) {
            console.error('Erro ao carregar termos:', error);
            alert('Erro ao carregar lista de termos');
        }
    }
    
    function atualizarDatalistTermos(termos) {
        const datalist = document.getElementById('datalistTermos');
        datalist.innerHTML = '';
        
        termos.forEach(termo => {
            const option = document.createElement('option');
            option.value = termo;
            datalist.appendChild(option);
        });
    }
    
    function filtrarTermos(busca) {
        if (!busca || busca.length < 2) {
            // Se busca muito curta, mostrar todos
            atualizarDatalistTermos(todosOsTermos);
            return;
        }
        
        // Filtrar termos que contenham o texto da busca (case-insensitive)
        const buscaLower = busca.toLowerCase();
        const termosFiltrados = todosOsTermos.filter(termo => 
            termo.toLowerCase().includes(buscaLower)
        );
        
        atualizarDatalistTermos(termosFiltrados);
    }

    async function carregarExtrato() {
        const timerTotal = performanceMetrics.start('carregarExtrato - TOTAL');
        
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) {
            linhas = [];
            renderizarTabela();
            document.getElementById('btnSalvar').style.display = 'none';
            document.getElementById('btnContrapartida').style.display = 'none';
            return;
        }

        try {
            document.getElementById('loadingIndicator').style.display = 'block';
            
            // Verificar se termo tem contrapartida
            verificarContrapartida(numeroTermo);
            
            // Se estiver no modo páginas, carregar todas as linhas para ter todos os meses
            const limiteParaCarregar = modoVisualizacao === 'paginas' ? 'todas' : limiteAtual;
            
            // Carregar categorias e período do termo em paralelo
            const timerParallel = performanceMetrics.start('carregarExtrato - Carregar metadados paralelos');
            await Promise.all([
                carregarCategoriasDespesas(numeroTermo),
                carregarCategoriasAnalise(),
                carregarPeriodoTermo(numeroTermo),
                carregarCategoriasAplicabilidade(),
                carregarCategoriasRubricas(numeroTermo)
            ]);
            performanceMetrics.end(timerParallel);
            
            // Carregar banco do termo
            const timerBanco = performanceMetrics.start('carregarExtrato - Carregar banco');
            await carregarBancoTermo(numeroTermo);
            performanceMetrics.end(timerBanco);
            
            const params = new URLSearchParams({
                numero_termo: numeroTermo,
                limite: limiteParaCarregar
            });
            
            const timerFetch = performanceMetrics.start('carregarExtrato - Fetch API extrato');
            const response = await fetch('/conc_bancaria/api/extrato?' + params.toString());
            if (!response.ok) throw new Error('Erro ao carregar extrato');
            performanceMetrics.end(timerFetch);
            
            const timerJSON = performanceMetrics.start('carregarExtrato - Parse JSON');
            const dados = await response.json();
            performanceMetrics.end(timerJSON);
            
            // Verificar se há autosave no cache para este termo
            const timerCache = performanceMetrics.start('carregarExtrato - Verificar cache');
            const cacheKey = `autosave_conc_${numeroTermo}`;
            const autosaveData = localStorage.getItem(cacheKey);
            let usarAutosave = false;
            
            if (autosaveData) {
                const { timestamp, linhas: linhasCache } = JSON.parse(autosaveData);
                const minutosPassados = (Date.now() - timestamp) / 1000 / 60;
                
                if (minutosPassados < 60) { // Cache válido por 1 hora
                    usarAutosave = confirm(`Há alterações não salvas de ${Math.round(minutosPassados)} minutos atrás. Deseja recuperá-las?`);
                    
                    if (usarAutosave) {
                        linhas = linhasCache;
                        proximoIndice = Math.max(...linhas.map(l => l.indice || 0)) + 1;
                    } else {
                        // Limpar cache se usuário recusar
                        localStorage.removeItem(cacheKey);
                    }
                }
            }
            
            if (!usarAutosave) {
                if (dados.length > 0) {
                    // Mapear campos do backend para o frontend
                    linhas = dados.map(item => ({
                        id: item.id,
                        indice: item.indice,
                        data: item.data,
                        credito: item.credito,
                        debito: item.debito,
                        discriminacao: item.discriminacao,
                        cat_transacao: item.cat_transacao,
                        competencia: item.competencia,
                        origem_destino: item.origem_destino,
                        cat_avaliacao: item.cat_avaliacao,
                        avaliacao_analista: item.avaliacao_analista,
                        mesclado_com: item.mesclado_com || []
                    }));
                    proximoIndice = Math.max(...linhas.map(l => l.indice || 0)) + 1;
                } else {
                    // Se não houver dados, iniciar vazio (usuário adiciona manualmente)
                    linhas = [];
                    proximoIndice = 1;
                }
            }
            performanceMetrics.end(timerCache);
            
            // Extrair meses disponíveis e inicializar navegação
            const timerMeses = performanceMetrics.start('carregarExtrato - Extrair meses');
            extrairMesesDisponiveis();
            popularSelectMeses();
            popularCheckboxesMeses();
            performanceMetrics.end(timerMeses);
            
            // Selecionar primeiro mês por padrão no modo páginas
            if (modoVisualizacao === 'paginas' && mesesDisponiveis.length > 0) {
                mesesSelecionados = [mesesDisponiveis[0]];
                document.getElementById('selectMesVisualizacao').value = mesesDisponiveis[0];
                atualizarCheckboxesMeses();
            }
            
            const timerRender = performanceMetrics.start('carregarExtrato - Renderizar tabela');
            renderizarTabela();
            performanceMetrics.end(timerRender);
            
            document.getElementById('btnSalvar').style.display = 'block';
            
            // Se seção de Notas Fiscais está ativa, carregar os dados
            if (secaoNotasFiscaisAtiva) {
                const timerNF = performanceMetrics.start('carregarExtrato - Carregar notas fiscais');
                await carregarNotasFiscais();
                performanceMetrics.end(timerNF);
            }
            
            performanceMetrics.end(timerTotal);
            
        } catch (error) {
            console.error('Erro ao carregar extrato:', error);
            alert('Erro ao carregar extrato');
        } finally {
            document.getElementById('loadingIndicator').style.display = 'none';
        }
    }

    function setLimite(limite) {
        limiteAtual = limite;
        carregarExtrato();
    }
    
    async function mudarModoVisualizacao() {
        const select = document.getElementById('selectModoVisualizacao');
        modoVisualizacao = select.value;
        
        const divNavegacao = document.getElementById('divNavegacaoMes');
        
        if (modoVisualizacao === 'paginas') {
            // No modo páginas, carregar TODAS as linhas para ter todos os meses disponíveis
            if (limiteAtual !== 'todas') {
                const confirmar = confirm('Para usar a paginação por mês, é necessário carregar todas as linhas.\n\nDeseja continuar?');
                if (!confirmar) {
                    select.value = 'todas';
                    modoVisualizacao = 'todas';
                    divNavegacao.style.display = 'none';
                    return;
                }
                limiteAtual = 'todas';
                await carregarExtrato();
            }
            
            divNavegacao.style.display = 'block';
            // Extrair meses únicos das linhas
            extrairMesesDisponiveis();
            popularSelectMeses();
            popularCheckboxesMeses();
            // Selecionar primeiro mês por padrão
            if (mesesDisponiveis.length > 0) {
                mesesSelecionados = [mesesDisponiveis[0]];
                document.getElementById('selectMesVisualizacao').value = mesesDisponiveis[0];
                atualizarCheckboxesMeses();
            }
            renderizarTabela();
        } else {
            divNavegacao.style.display = 'none';
            mesesSelecionados = [];
            renderizarTabela();
        }
    }
    
    function extrairMesesDisponiveis() {
        const mesesSet = new Set();
        
        // Extrair de TODAS as linhas carregadas, não só as exibidas
        linhas.forEach(linha => {
            if (linha.data) {
                const partes = linha.data.split('-');
                if (partes.length === 3) {
                    const mesAno = `${partes[1]}/${partes[0]}`;
                    mesesSet.add(mesAno);
                }
            }
        });
        
        // Ordenar meses cronologicamente
        mesesDisponiveis = Array.from(mesesSet).sort((a, b) => {
            const [mesA, anoA] = a.split('/');
            const [mesB, anoB] = b.split('/');
            const dataA = new Date(anoA, mesA - 1);
            const dataB = new Date(anoB, mesB - 1);
            return dataA - dataB;
        });
        
        console.log(`Meses disponíveis extraídos: ${mesesDisponiveis.length}`, mesesDisponiveis);
    }
    
    function popularSelectMeses() {
        const select = document.getElementById('selectMesVisualizacao');
        select.innerHTML = '<option value="">Selecione um mês...</option>';
        
        mesesDisponiveis.forEach(mes => {
            const option = document.createElement('option');
            option.value = mes;
            option.textContent = mes;
            select.appendChild(option);
        });
    }
    
    function mudarMesSelecionado() {
        const select = document.getElementById('selectMesVisualizacao');
        const mesSelecionado = select.value;
        
        if (mesSelecionado) {
            mesesSelecionados = [mesSelecionado];
            // Atualizar checkboxes
            atualizarCheckboxesMeses();
            renderizarTabela();
        }
    }
    
    function popularCheckboxesMeses() {
        const container = document.getElementById('checkboxesMeses');
        container.innerHTML = '';
        
        if (mesesDisponiveis.length === 0) {
            container.innerHTML = '<p class="text-muted text-center mb-0">Nenhum mês disponível</p>';
            return;
        }
        
        mesesDisponiveis.forEach(mes => {
            const div = document.createElement('div');
            div.className = 'form-check';
            
            const checkbox = document.createElement('input');
            checkbox.className = 'form-check-input';
            checkbox.type = 'checkbox';
            checkbox.value = mes;
            checkbox.id = `checkMes_${mes.replace('/', '_')}`;
            checkbox.onchange = () => toggleMesSelecionado(mes);
            
            const label = document.createElement('label');
            label.className = 'form-check-label';
            label.htmlFor = checkbox.id;
            label.textContent = mes;
            
            div.appendChild(checkbox);
            div.appendChild(label);
            container.appendChild(div);
        });
    }
    
    function toggleMesSelecionado(mes) {
        const index = mesesSelecionados.indexOf(mes);
        if (index > -1) {
            mesesSelecionados.splice(index, 1);
        } else {
            mesesSelecionados.push(mes);
        }
        
        // Atualizar select para mostrar primeiro mês selecionado ou vazio
        const select = document.getElementById('selectMesVisualizacao');
        if (mesesSelecionados.length > 0) {
            select.value = mesesSelecionados[0];
        } else {
            select.value = '';
        }
        
        renderizarTabela();
    }
    
    function atualizarCheckboxesMeses() {
        mesesDisponiveis.forEach(mes => {
            const checkbox = document.getElementById(`checkMes_${mes.replace('/', '_')}`);
            if (checkbox) {
                checkbox.checked = mesesSelecionados.includes(mes);
            }
        });
    }
    
    function selecionarTodosMeses() {
        mesesSelecionados = [...mesesDisponiveis];
        atualizarCheckboxesMeses();
        const select = document.getElementById('selectMesVisualizacao');
        if (mesesSelecionados.length > 0) {
            select.value = mesesSelecionados[0];
        }
        renderizarTabela();
    }
    
    function desmarcarTodosMeses() {
        mesesSelecionados = [];
        atualizarCheckboxesMeses();
        document.getElementById('selectMesVisualizacao').value = '';
        renderizarTabela();
    }
    
    async function carregarCategoriasDespesas(numeroTermo) {
        try {
            const response = await fetch(`/conc_bancaria/api/categorias-despesas?numero_termo=${encodeURIComponent(numeroTermo)}`);
            if (!response.ok) throw new Error('Erro ao carregar categorias de despesas');
            categoriasDespesas = await response.json();
        } catch (error) {
            console.error('Erro ao carregar categorias de despesas:', error);
            categoriasDespesas = [];
        }
    }
    
    async function carregarCategoriasAnalise() {
        try {
            const response = await fetch('/conc_bancaria/api/categorias-analise');
            if (!response.ok) throw new Error('Erro ao carregar categorias de análise');
            categoriasAnalise = await response.json();
        } catch (error) {
            console.error('Erro ao carregar categorias de análise:', error);
            categoriasAnalise = [];
        }
    }
    
    async function carregarCategoriasAplicabilidade() {
        try {
            const response = await fetch('/conc_bancaria/api/categorias-aplicabilidade');
            if (!response.ok) throw new Error('Erro ao carregar aplicabilidade');
            categoriasAplicabilidade = await response.json();
            console.log('Aplicabilidade carregada:', categoriasAplicabilidade);
        } catch (error) {
            console.error('Erro ao carregar aplicabilidade:', error);
            categoriasAplicabilidade = {};
        }
    }
    
    async function carregarCategoriasRubricas(numeroTermo) {
        try {
            const response = await fetch(`/conc_bancaria/api/categorias-rubricas?numero_termo=${encodeURIComponent(numeroTermo)}`);
            if (!response.ok) throw new Error('Erro ao carregar rubricas');
            categoriasRubricas = await response.json();
            console.log('Rubricas carregadas:', categoriasRubricas);
        } catch (error) {
            console.error('Erro ao carregar rubricas:', error);
            categoriasRubricas = {};
        }
    }
    
    async function carregarNotasFiscais() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) return;
        
        try {
            const response = await fetch(`/conc_bancaria/api/notas-fiscais?numero_termo=${encodeURIComponent(numeroTermo)}`);
            if (!response.ok) throw new Error('Erro ao carregar notas fiscais');
            
            const notas = await response.json();
            
            // Indexar por conc_extrato_id
            notasFiscais = {};
            notas.forEach(nota => {
                notasFiscais[nota.conc_extrato_id] = {
                    id: nota.id,
                    numero_nota: nota.numero_nota || '',
                    chave_acesso: nota.chave_acesso || '',
                    cnpj_nota: nota.cnpj_nota || ''
                };
            });
            
            console.log(`Notas fiscais carregadas: ${notas.length}`);
            console.log('Mapeamento notasFiscais:', notasFiscais);
            
            // Debug: mostrar quais linhas têm ID correspondente
            if (notas.length > 0) {
                console.log('IDs das linhas do extrato:', linhas.map((l, i) => `Índice ${l.indice}: ID=${l.id}`));
                notas.forEach(nf => {
                    const linhaCorrespondente = linhas.find(l => l.id === nf.conc_extrato_id);
                    if (linhaCorrespondente) {
                        console.log(`✓ NF encontrada: Nota ${nf.numero_nota} está na linha com índice ${linhaCorrespondente.indice} (ID=${nf.conc_extrato_id})`);
                    } else {
                        console.warn(`⚠ NF órfã: Nota ${nf.numero_nota} tem conc_extrato_id=${nf.conc_extrato_id}, mas não há linha com esse ID`);
                    }
                });
            }
        } catch (error) {
            console.error('Erro ao carregar notas fiscais:', error);
            notasFiscais = {};
        }
    }
    
    async function carregarDocumentosAnalise() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) return;
        
        try {
            const response = await fetch(`/conc_bancaria/api/documentos-analise?numero_termo=${encodeURIComponent(numeroTermo)}`);
            if (!response.ok) throw new Error('Erro ao carregar documentos de análise');
            
            const documentos = await response.json();
            
            // Indexar por conc_extrato_id e fazer migração de dados antigos SOMENTE no carregamento
            documentosAnalise = {};
            documentos.forEach(doc => {
                // Migração de valores antigos para novos (só acontece aqui, uma vez)
                let valorGuia = doc.avaliacao_guia || '';
                if (valorGuia === 'aprovado') valorGuia = 'Guia apresentada';
                else if (valorGuia === 'pendente') valorGuia = 'Não apresentada';
                // Valores já migrados ou novos permanecem como estão
                
                let valorComprovante = doc.avaliacao_comprovante || '';
                if (valorComprovante === 'aprovado') valorComprovante = 'Apresentado corretamente';
                else if (valorComprovante === 'pendente') valorComprovante = 'Não apresentado';
                // Valores já migrados permanecem como estão
                
                let valorContratos = doc.avaliacao_contratos || '';
                if (valorContratos === 'aprovado') valorContratos = 'Contratos apresentados';
                // Outros valores permanecem como estão
                
                let valorForaMunicipio = doc.avaliacao_fora_municipio || '';
                if (valorForaMunicipio === 'aprovado') valorForaMunicipio = 'São Paulo';
                // Outros valores permanecem como estão
                
                documentosAnalise[doc.conc_extrato_id] = {
                    id: doc.id,
                    avaliacao_guia: valorGuia,
                    avaliacao_comprovante: valorComprovante,
                    avaliacao_contratos: valorContratos,
                    avaliacao_fora_municipio: valorForaMunicipio
                };
            });
            
            console.log(`Documentos de análise carregados: ${documentos.length}`);
            
        } catch (error) {
            console.error('Erro ao carregar documentos de análise:', error);
            documentosAnalise = {};
        }
    }
    
    function obterCategoriasFiltradas(linha) {
        const categorias = [];
        const temCredito = linha.credito && linha.credito > 0;
        const temDebito = linha.debito && linha.debito > 0;
        
        // Adicionar categorias de despesas do termo
        categoriasDespesas.forEach(cat => {
            categorias.push({
                valor: cat.categoria_despesa,
                label: cat.categoria_despesa,
                tipo: 'despesa'
            });
        });
        
        // Adicionar categorias de análise filtradas por tipo de transação
        categoriasAnalise.forEach(cat => {
            const tipo = cat.tipo_transacao;
            let adicionar = false;
            
            if (tipo === 'Débito / Crédito') {
                adicionar = true; // Sempre adicionar
            } else if (temCredito && tipo === 'Crédito') {
                adicionar = true;
            } else if (temDebito && tipo === 'Débito') {
                adicionar = true;
            }
            
            if (adicionar) {
                categorias.push({
                    valor: cat.categoria_extra,
                    label: cat.categoria_extra,
                    tipo: 'analise'
                });
            }
        });
        
        // Remover duplicatas
        return categorias.filter((cat, index, self) => 
            index === self.findIndex(c => c.valor === cat.valor)
        );
    }
    
    async function carregarPeriodoTermo(numeroTermo) {
        try {
            const response = await fetch(`/conc_bancaria/api/periodo-termo?numero_termo=${encodeURIComponent(numeroTermo)}`);
            if (!response.ok) throw new Error('Erro ao carregar período do termo');
            const dados = await response.json();
            periodoTermo = dados;
        } catch (error) {
            console.error('Erro ao carregar período do termo:', error);
            periodoTermo = { inicio: null, final: null };
        }
    }
    
    async function carregarBancoTermo(numeroTermo) {
        try {
            const response = await fetch(`/conc_bancaria/api/banco?numero_termo=${encodeURIComponent(numeroTermo)}`);
            if (!response.ok) throw new Error('Erro ao carregar banco');
            const dados = await response.json();
            
            if (dados.banco_extrato) {
                document.getElementById('bancoExtrato').value = dados.banco_extrato;
                bancoAtual = dados.banco_extrato;
            } else {
                document.getElementById('bancoExtrato').value = '';
                bancoAtual = '';
            }
        } catch (error) {
            console.error('Erro ao carregar banco do termo:', error);
            document.getElementById('bancoExtrato').value = '';
            bancoAtual = '';
        }
    }
    
    function validarCompetencia(competenciaStr) {
        if (!competenciaStr || !periodoTermo.inicio || !periodoTermo.final) {
            return { valido: true, mensagem: '' };
        }
        
        // Converter competencia (formato: AAAA-MM-DD onde DD=01) para Date
        const competencia = new Date(competenciaStr);
        const inicio = new Date(periodoTermo.inicio);
        const final = new Date(periodoTermo.final);
        
        // Calcular limites com tolerância
        const limiteInicio = new Date(inicio);
        limiteInicio.setMonth(limiteInicio.getMonth() - 2); // 2 meses antes
        
        const limiteFinal = new Date(final);
        limiteFinal.setMonth(limiteFinal.getMonth() + 6); // 6 meses depois
        
        if (competencia < limiteInicio || competencia > limiteFinal) {
            const mesInicio = (limiteInicio.getMonth() + 1).toString().padStart(2, '0');
            const anoInicio = limiteInicio.getFullYear();
            const mesFinal = (limiteFinal.getMonth() + 1).toString().padStart(2, '0');
            const anoFinal = limiteFinal.getFullYear();
            
            return {
                valido: false,
                mensagem: `Competência fora do período permitido (${mesInicio}/${anoInicio} a ${mesFinal}/${anoFinal})`
            };
        }
        
        return { valido: true, mensagem: '' };
    }
    
    function formatarCompetenciaParaExibicao(dataStr) {
        if (!dataStr) return '';
        // Verificar se é a data especial "Sem competência"
        if (dataStr === '2000-01-01') return 'Sem competência';
        // Parse manual para evitar problemas com timezone: "2025-05-01" -> [2025, 05, 01]
        const partes = dataStr.split('-');
        const ano = partes[0];
        const mes = parseInt(partes[1]) - 1; // Mês é 0-indexed
        const meses = ['jan', 'fev', 'mar', 'abr', 'mai', 'jun', 'jul', 'ago', 'set', 'out', 'nov', 'dez'];
        return `${meses[mes]}/${ano}`;
    }
    
    function calcularCompetenciaAutomatica(dataStr) {
        if (!dataStr) return null;
        // Parse manual: "2025-05-15" -> [2025, 05, 15]
        const partes = dataStr.split('-');
        const ano = partes[0];
        const mes = partes[1]; // Já está com zero-padding
        // Retornar sempre o dia 01 do mês/ano
        return `${ano}-${mes}-01`;
    }
    
    function parseCompetencia(competenciaStr) {
        // Aceita formatos: MM/AAAA ou DD/MM/AAAA
        if (!competenciaStr) return null;
        
        const partes = competenciaStr.trim().split('/');
        
        if (partes.length === 2) {
            // Formato: MM/AAAA ou MM/AA
            const mes = parseInt(partes[0]);
            let ano = parseInt(partes[1]);
            
            // Se ano tem 2 dígitos, converter para 4 (assumir 20XX se >= 00 e <= 99)
            if (ano >= 0 && ano <= 99) {
                ano = 2000 + ano;
            }
            
            if (mes >= 1 && mes <= 12 && ano > 1900) {
                return `${ano}-${mes.toString().padStart(2, '0')}-01`;
            }
        } else if (partes.length === 3) {
            // Formato: DD/MM/AAAA ou DD/MM/AA - ignorar dia, sempre usar 01
            const mes = parseInt(partes[1]);
            let ano = parseInt(partes[2]);
            
            // Se ano tem 2 dígitos, converter para 4
            if (ano >= 0 && ano <= 99) {
                ano = 2000 + ano;
            }
            
            if (mes >= 1 && mes <= 12 && ano > 1900) {
                return `${ano}-${mes.toString().padStart(2, '0')}-01`;
            }
        }
        
        return null;
    }

    function atualizarCompetencia(index, valorInput) {
        // Verificar se é "Sem competência"
        if (valorInput && valorInput.trim().toLowerCase() === 'sem competência') {
            linhas[index].competencia = '2000-01-01';
            linhas[index].competencia_valida = true;
            linhas[index].competencia_erro = null;
            delete linhas[index]._competencia_deletada; // Não é deleção, é valor especial
            
            // Atualização otimizada: só atualizar a célula, não toda a tabela
            const row = document.querySelector(`tr[data-index="${index}"]`);
            if (row) {
                const competenciaCell = row.cells[6]; // Coluna 7 Competência (index 6)
                const input = competenciaCell.querySelector('input');
                if (input) {
                    input.value = 'Sem competência';
                    input.classList.remove('is-invalid');
                    const feedback = competenciaCell.querySelector('.invalid-feedback');
                    if (feedback) feedback.remove();
                }
            }
            
            agendarAutosave();
            return;
        }
        
        // Parse do input do usuário
        const competenciaParsed = parseCompetencia(valorInput);
        
        if (!competenciaParsed) {
            linhas[index].competencia = null;
            linhas[index].competencia_valida = false;
            linhas[index].competencia_erro = 'Formato inválido. Use MM/AAAA ou "Sem competência"';
            renderizarTabela(); // Só renderiza quando há erro para mostrar mensagem
            return;
        }
        
        // Validar contra período do termo
        const validacao = validarCompetencia(competenciaParsed);
        
        linhas[index].competencia = competenciaParsed;
        linhas[index].competencia_valida = validacao.valido;
        linhas[index].competencia_erro = validacao.valido ? null : validacao.mensagem;
        
        if (!validacao.valido) {
            renderizarTabela(); // Só renderiza quando há erro para mostrar mensagem
        } else {
            // Atualização otimizada para competências válidas
            const row = document.querySelector(`tr[data-index="${index}"]`);
            if (row) {
                const competenciaCell = row.cells[6]; // Coluna 7 Competência (index 6)
                const input = competenciaCell.querySelector('input');
                if (input) {
                    input.classList.remove('is-invalid');
                    const feedback = competenciaCell.querySelector('.invalid-feedback');
                    if (feedback) feedback.remove();
                }
            }
            agendarAutosave();
        }
    }

    function formatarExibicaoCompetencia(index, input) {
        // Ao sair do campo, formatar para exibição (mai/2025)
        if (linhas[index].competencia && linhas[index].competencia_valida !== false) {
            input.value = formatarCompetenciaParaExibicao(linhas[index].competencia);
        }
    }

    async function adicionarLinha() {
        // Se estamos em modo limitado (100 ou 200), carregar todas as linhas primeiro
        // para evitar conflitos de índice com linhas que existem no banco
        if (limiteAtual !== 'todas') {
            const confirmar = confirm(
                'Para adicionar novas linhas com segurança, o sistema precisa carregar TODAS as linhas disponíveis.\n\n' +
                'Deseja continuar?'
            );
            
            if (!confirmar) return;
            
            // Carregar todas as linhas
            limiteAtual = 'todas';
            await carregarExtrato();
        }
        
        const linha = {
            id: null,
            indice: proximoIndice++,
            data: '',
            credito: null,
            debito: null,
            discriminacao: null,
            cat_transacao: null,
            competencia: null,
            origem_destino: null,
            cat_avaliacao: null,
            avaliacao_analista: null,
            mesclado_com: [],
            _novo: true
        };
        
        linhas.push(linha);
        renderizarTabela();
        document.getElementById('btnSalvar').style.display = 'block';
    }

    async function adicionarLinhaAcima(index) {
        // Se estamos em modo limitado (100 ou 200), carregar todas as linhas primeiro
        if (limiteAtual !== 'todas') {
            const confirmar = confirm(
                'Para adicionar novas linhas com segurança, o sistema precisa carregar TODAS as linhas disponíveis.\n\n' +
                'Deseja continuar?'
            );
            
            if (!confirmar) return;
            
            // Carregar todas as linhas
            limiteAtual = 'todas';
            await carregarExtrato();
        }
        
        const novaLinha = {
            id: null,
            indice: 0, // Será recalculado
            data: '',
            credito: null,
            debito: null,
            discriminacao: null,
            cat_transacao: null,
            competencia: null,
            origem_destino: null,
            cat_avaliacao: null,
            avaliacao_analista: null,
            mesclado_com: [],
            _novo: true
        };
        
        linhas.splice(index, 0, novaLinha);
        recalcularIndices();
        renderizarTabela();
        document.getElementById('btnSalvar').style.display = 'block';
    }

    async function adicionarLinhasEmLote() {
        // Se estamos em modo limitado (100 ou 200), carregar todas as linhas primeiro
        if (limiteAtual !== 'todas') {
            const confirmar = confirm(
                'Para adicionar novas linhas com segurança, o sistema precisa carregar TODAS as linhas disponíveis.\n\n' +
                'Deseja continuar?'
            );
            
            if (!confirmar) return;
            
            // Carregar todas as linhas
            limiteAtual = 'todas';
            await carregarExtrato();
        }
        
        const input = document.getElementById('inputAdicionarLinhas');
        const quantidade = parseInt(input.value);
        
        if (isNaN(quantidade) || quantidade < 1) {
            alert('Digite uma quantidade válida (mínimo 1)');
            return;
        }
        
        if (quantidade > 100) {
            if (!confirm(`Você está adicionando ${quantidade} linhas. Isso pode deixar a página lenta. Continuar?`)) {
                return;
            }
        }
        
        // Salvar estado antes de adicionar
        salvarEstadoNoHistorico();
        
        // Adicionar múltiplas linhas vazias
        for (let i = 0; i < quantidade; i++) {
            const novaLinha = {
                id: null,
                indice: 0, // Será recalculado
                data: '',
                credito: null,
                debito: null,
                discriminacao: null,
                cat_transacao: null,
                competencia: null,
                origem_destino: null,
                cat_avaliacao: null,
                avaliacao_analista: null,
                mesclado_com: [],
                _novo: true
            };
            linhas.push(novaLinha);
        }
        
        recalcularIndices();
        renderizarTabela();
        document.getElementById('btnSalvar').style.display = 'block';
        
        // Resetar input
        input.value = '1';
    }

    async function adicionarLinhaAbaixo(index) {
        // Não precisa mais recarregar - adiciona localmente mesmo em modo limitado
        
        const novaLinha = {
            id: null,
            indice: 0, // Será recalculado
            data: '',
            credito: null,
            debito: null,
            discriminacao: null,
            cat_transacao: null,
            competencia: null,
            origem_destino: null,
            cat_avaliacao: null,
            avaliacao_analista: null,
            mesclado_com: [],
            _novo: true
        };
        
        linhas.splice(index + 1, 0, novaLinha);
        recalcularIndices();
        renderizarTabela();
        document.getElementById('btnSalvar').style.display = 'block';
        
        // Scroll para a nova linha
        setTimeout(() => {
            const tbody = document.getElementById('tbodyConciliacao');
            const novaRow = tbody.children[index + 1];
            if (novaRow) {
                novaRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
    }

    function duplicarLinha(index, direcao) {
        const linhaOriginal = linhas[index];
        
        // Criar cópia da linha (sem id para forçar INSERT)
        const linhaDuplicada = {
            id: null, // Sem ID = nova linha no banco
            indice: 0, // Será recalculado
            data: linhaOriginal.data,
            credito: linhaOriginal.credito,
            debito: linhaOriginal.debito,
            discriminacao: linhaOriginal.discriminacao,
            cat_transacao: linhaOriginal.cat_transacao,
            competencia: linhaOriginal.competencia,
            origem_destino: linhaOriginal.origem_destino,
            cat_avaliacao: linhaOriginal.cat_avaliacao,
            avaliacao_analista: linhaOriginal.avaliacao_analista,
            mesclado_com: [],
            _novo: true
        };
        
        // Inserir acima ou abaixo
        if (direcao === 'acima') {
            linhas.splice(index, 0, linhaDuplicada);
        } else {
            linhas.splice(index + 1, 0, linhaDuplicada);
        }
        
        recalcularIndices();
        renderizarTabela();
        document.getElementById('btnSalvar').style.display = 'block';
    }

    function aplicarAutoPreenchimento() {
        /**
         * Aplica auto-preenchimentos nas linhas (competência, origem/destino, avaliação)
         * sem salvar no banco - apenas atualiza o estado local
         */
        const bancoExtrato = document.getElementById('bancoExtrato').value;
        
        linhas.forEach(linha => {
            // Auto-preencher competência se estiver vazia mas tiver data
            if (!linha.competencia && linha.data && !linha._competencia_deletada) {
                linha.competencia = calcularCompetenciaAutomatica(linha.data);
            }
            
            // Auto-preencher origem_destino se estiver vazia mas tiver categoria
            if (!linha.origem_destino && linha.cat_transacao) {
                const categoria = categoriasAnalise.find(cat => cat.categoria_extra === linha.cat_transacao);
                if (categoria && categoria.correspondente) {
                    let origemDestino = categoria.correspondente;
                    
                    // Se o correspondente for "Banco", substituir pelo banco atual do termo
                    if (origemDestino === 'Banco' && bancoAtual) {
                        origemDestino = bancoAtual;
                    }
                    
                    linha.origem_destino = origemDestino;
                }
            }
            
            // Auto-classificar avaliação baseado em regras
            if (!linha.cat_avaliacao) {
                // Regra prioritária: Categoria de Transação
                if (linha.cat_transacao && regrasAvaliacao.glosar.includes(linha.cat_transacao)) {
                    linha.cat_avaliacao = 'Glosar';
                }
                // Regra secundária: Origem/Destino
                else if (linha.origem_destino) {
                    const origemNormalizada = linha.origem_destino.toLowerCase().trim();
                    if (regrasAvaliacao.avaliado.includes(origemNormalizada)) {
                        linha.cat_avaliacao = 'Avaliado';
                    }
                }
            }
            
            // Auto-preencher composição se estiver vazia
            if (!linha.discriminacao && (linha.credito || linha.debito)) {
                linha.discriminacao = linha.credito || linha.debito;
            }
        });
    }

    function renderizarTabela(skipFilters = false) {
        const timerTotal = performanceMetrics.start('renderizarTabela - TOTAL');
        
        // Aplicar auto-preenchimentos antes de renderizar
        aplicarAutoPreenchimento();
        
        const tbody = document.getElementById('tbodyConciliacao');
        
        const timerFiltro = performanceMetrics.start('renderizarTabela - Construir HTML');
        
        // OTIMIZAÇÃO 1: Usar DocumentFragment para construir DOM antes de inserir
        const fragment = document.createDocumentFragment();
        
        // OTIMIZAÇÃO 2: Cachear grupos de composição usando WeakMap global
        // Calcular apenas para linhas que não estão no cache
        linhas.forEach((linha, idx) => {
            if (!gruposComposicaoCache.has(linha)) {
                gruposComposicaoCache.set(linha, identificarGrupoComposicao(idx));
            }
        });

        // Filtrar linhas por mês se estiver no modo páginas
        let linhasFiltradas = linhas;
        if (modoVisualizacao === 'paginas' && mesesSelecionados.length > 0) {
            linhasFiltradas = linhas.filter(linha => {
                if (!linha.data) return false;
                const partes = linha.data.split('-');
                if (partes.length === 3) {
                    const mesAno = `${partes[1]}/${partes[0]}`;
                    return mesesSelecionados.includes(mesAno);
                }
                return false;
            });
        }

        linhasFiltradas.forEach((linha, filteredIndex) => {
            // Encontrar índice real da linha no array original
            const index = linhas.indexOf(linha);
            
            const tr = document.createElement('tr');
            tr.dataset.index = index;
            
            // Aplicar classe de cor baseado na avaliação
            if (linha.cat_avaliacao === 'Avaliado') {
                tr.classList.add('avaliacao-avaliado');
            } else if (linha.cat_avaliacao === 'Aguardando resposta') {
                tr.classList.add('avaliacao-aguardando');
            } else if (linha.cat_avaliacao === 'Pessoa Gestora') {
                tr.classList.add('avaliacao-pessoa-gestora');
            } else if (linha.cat_avaliacao === 'Glosar') {
                tr.classList.add('avaliacao-glosar');
            }
            
            // Detectar mudança de mês: se há linha anterior e o mês mudou
            // Aplicar borda na linha ATUAL (que inicia o novo mês)
            if (index > 0) {
                const linhaAnterior = linhas[index - 1];
                if (linha.data && linhaAnterior.data) {
                    // Parse manual para evitar problemas de timezone
                    const partesAtual = linha.data.split('-'); // "2017-08-01" -> ["2017", "08", "01"]
                    const partesAnterior = linhaAnterior.data.split('-');
                    
                    const anoAtual = parseInt(partesAtual[0]);
                    const mesAtual = parseInt(partesAtual[1]);
                    const anoAnterior = parseInt(partesAnterior[0]);
                    const mesAnterior = parseInt(partesAnterior[1]);
                    
                    // Se mudou o mês ou ano, adicionar classe de separação na linha ATUAL
                    if (mesAtual !== mesAnterior || anoAtual !== anoAnterior) {
                        tr.classList.add('mudanca-mes');
                    }
                }
            }
            
            // OTIMIZAÇÃO: Usar grupo de composição do cache WeakMap
            const grupoInfo = gruposComposicaoCache.get(linha);
            
            // OTIMIZAÇÃO CRÍTICA: Construir HTML com array.join() ao invés de innerHTML +=
            // Elimina reparse O(n²) -> O(n)
            const htmlParts = [];
            
            // Célula de índice
            htmlParts.push(`<td class="text-center">${linha.indice || ''}</td>`);
            
            // Célula de Data
            htmlParts.push(`
                <td>
                    <input type="text" 
                           class="cell-input" 
                           value="${linha.data ? formatarDataParaExibicao(linha.data) : ''}" 
                           onchange="atualizarCampoData(${index}, this.value)"
                           onkeydown="navegarCelulaData(event, ${index})"
                           placeholder="dd/mm/aaaa"
                           maxlength="10">
                </td>
            `);
            
            // Célula de Crédito
            if (linha.credito) {
                if (grupoInfo && grupoInfo.ehGrupo && grupoInfo.tipo === 'credito' && !grupoInfo.ehPrimeira) {
                    htmlParts.push(`
                        <td class="${linha.debito ? 'cell-disabled' : ''}" style="background-color: #e8f5e9;">
                            <div style="text-align: center; padding: 6px; color: #2e7d32; font-style: italic;">
                                Crédito composto
                            </div>
                        </td>
                    `);
                } else {
                    htmlParts.push(`
                        <td class="${linha.debito ? 'cell-disabled' : ''}">
                            <input type="text" class="cell-input cell-money" 
                                   value="${formatarMoeda(linha.credito)}" 
                                   ${linha.debito ? 'disabled' : ''}
                                   onchange="atualizarValor(${index}, 'credito', this.value)"
                                   onblur="blurCondicional(${index}, this)"
                                   onkeydown="navegarCelula(event, ${index}, 1)">
                        </td>
                    `);
                }
            } else {
                htmlParts.push(`
                    <td class="${linha.debito ? 'cell-disabled' : ''}">
                        <input type="text" class="cell-input cell-money" 
                               value="${formatarMoeda(linha.credito)}" 
                               ${linha.debito ? 'disabled' : ''}
                               onchange="atualizarValor(${index}, 'credito', this.value)"
                               onblur="blurCondicional(${index}, this)"
                               onkeydown="navegarCelula(event, ${index}, 1)">
                    </td>
                `);
            }
            
            // Célula de Débito
            if (linha.debito) {
                if (grupoInfo && grupoInfo.ehGrupo && grupoInfo.tipo === 'debito' && !grupoInfo.ehPrimeira) {
                    htmlParts.push(`
                        <td class="${linha.credito ? 'cell-disabled' : ''}" style="background-color: #ffebee;">
                            <div style="text-align: center; padding: 6px; color: #c62828; font-style: italic;">
                                Débito composto
                            </div>
                        </td>
                    `);
                } else {
                    htmlParts.push(`
                        <td class="${linha.credito ? 'cell-disabled' : ''}">
                            <input type="text" class="cell-input cell-money" 
                                   value="${formatarMoeda(linha.debito)}" 
                                   ${linha.credito ? 'disabled' : ''}
                                   onchange="atualizarValor(${index}, 'debito', this.value)"
                                   onblur="blurCondicional(${index}, this)"
                                   onkeydown="navegarCelula(event, ${index}, 2)">
                        </td>
                    `);
                }
            } else {
                htmlParts.push(`
                    <td class="${linha.credito ? 'cell-disabled' : ''}">
                        <input type="text" class="cell-input cell-money" 
                               value="${formatarMoeda(linha.debito)}" 
                               ${linha.credito ? 'disabled' : ''}
                               onchange="atualizarValor(${index}, 'debito', this.value)"
                               onblur="blurCondicional(${index}, this)"
                               onkeydown="navegarCelula(event, ${index}, 2)">
                    </td>
                `);
            }
            
            // Renderizar input com datalist de categoria (busca sugestiva)
            const categoriasFiltradas = obterCategoriasFiltradas(linha);
            const datalistId = `datalist-cat-${index}`;
            let htmlCategoria = `
                <input type="text" 
                       class="form-control form-control-sm cell-input" 
                       list="${datalistId}"
                       value="${linha.cat_transacao || ''}" 
                       onchange="atualizarCampo(${index}, 'cat_transacao', this.value)"
                       onblur="blurCondicionalCategoria(${index})"
                       onkeydown="navegarCelula(event, ${index}, 4)"
                       placeholder="Digite para buscar..."
                       autocomplete="off">
                <datalist id="${datalistId}">
            `;
            categoriasFiltradas.forEach(cat => {
                htmlCategoria += `<option value="${cat.valor}">${cat.label}</option>`;
            });
            htmlCategoria += '</datalist>';
            
            //  Continuar construindo htmlParts com as células restantes
            htmlParts.push(`
                <td class="${!validarComposicao(index) ? 'composicao-invalida' : ''}">
                    <input type="text" class="cell-input cell-money" 
                           value="${formatarMoeda(linha.discriminacao)}" 
                           onchange="atualizarValor(${index}, 'discriminacao', this.value)"
                           onblur="blurCondicional(${index}, this)"
                           onkeydown="navegarCelula(event, ${index}, 3)">
                </td>
                <td>${htmlCategoria}</td>
                <td>
                    <input type="text" 
                           class="cell-input competencia-input ${linha.competencia_valida === false ? 'is-invalid' : ''}" 
                           value="${linha.competencia ? formatarCompetenciaParaExibicao(linha.competencia) : ''}" 
                           onchange="atualizarCompetencia(${index}, this.value)"
                           onblur="formatarExibicaoCompetencia(${index}, this)"
                           onkeydown="navegarCelula(event, ${index}, 5)"
                           list="datalistCompetencia"
                           placeholder="MM/AAAA ou Sem competência"
                           autocomplete="off">
                    ${linha.competencia_erro ? `<div class="invalid-feedback d-block">${linha.competencia_erro}</div>` : ''}
                </td>
                <td>
                    <input type="text" 
                           class="cell-input" 
                           list="datalistOrigemDestino"
                           value="${linha.origem_destino || ''}" 
                           onchange="atualizarCampo(${index}, 'origem_destino', this.value)"
                           onkeydown="navegarCelulaOrigemDestino(event, ${index})"
                           placeholder="Origem ou destino..."
                           autocomplete="off">
                </td>
                <td>
                    <input type="text" 
                           class="cell-input" 
                           list="datalistAvaliacoes"
                           value="${linha.cat_avaliacao || ''}" 
                           onchange="atualizarCampo(${index}, 'cat_avaliacao', this.value)"
                           onblur="aplicarCorLinha(${index})"
                           onkeydown="navegarCelula(event, ${index}, 7)"
                           placeholder="Selecione..."
                           autocomplete="off">
                </td>
                <td>
                    <input type="text" 
                           class="cell-input" 
                           value="${linha.avaliacao_analista || ''}" 
                           onchange="atualizarCampo(${index}, 'avaliacao_analista', this.value)"
                           onkeydown="navegarCelula(event, ${index}, 8)"
                           list="datalistObservacoes"
                           placeholder="Observações..."
                           autocomplete="off">
                </td>
                <td class="text-center text-nowrap">
                    <div class="dropdown">
                        <button class="btn btn-sm btn-primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi bi-three-dots-vertical"></i> Ações
                        </button>
                        <ul class="dropdown-menu">
                            <!-- Adicionar Linhas -->
                            <li><h6 class="dropdown-header"><i class="bi bi-plus-circle"></i> Adicionar</h6></li>
                            <li><a class="dropdown-item" href="#" onclick="event.preventDefault(); adicionarLinhaAcima(${index})">
                                <i class="bi bi-arrow-up-circle me-2"></i>Adicionar linha acima
                            </a></li>
                            <li><a class="dropdown-item" href="#" onclick="event.preventDefault(); adicionarLinhaAbaixo(${index})">
                                <i class="bi bi-arrow-down-circle me-2"></i>Adicionar linha abaixo
                            </a></li>
                            <li><a class="dropdown-item" href="#" onclick="event.preventDefault(); duplicarLinha(${index}, 'acima')">
                                <i class="bi bi-files me-2"></i>Duplicar linha acima
                            </a></li>
                            <li><a class="dropdown-item" href="#" onclick="event.preventDefault(); duplicarLinha(${index}, 'abaixo')">
                                <i class="bi bi-files me-2"></i>Duplicar linha abaixo
                            </a></li>
                            
                            <li><hr class="dropdown-divider"></li>
                            <li><h6 class="dropdown-header"><i class="bi bi-arrows-move"></i> Movimentação</h6></li>
                            <li><a class="dropdown-item ${index === 0 ? 'disabled' : ''}" href="#" onclick="event.preventDefault(); moverLinha(${index}, -1)">
                                <i class="bi bi-arrow-up me-2"></i>Mover para cima
                            </a></li>
                            <li><a class="dropdown-item ${index === linhas.length - 1 ? 'disabled' : ''}" href="#" onclick="event.preventDefault(); moverLinha(${index}, 1)">
                                <i class="bi bi-arrow-down me-2"></i>Mover para baixo
                            </a></li>
                            
                            <li><hr class="dropdown-divider"></li>
                            <li><h6 class="dropdown-header"><i class="bi bi-gear"></i> Outras Ações</h6></li>
                            <li><a class="dropdown-item ${index === 0 ? 'disabled' : ''}" href="#" onclick="event.preventDefault(); copiarDataAcima(${index})">
                                <i class="bi bi-calendar-plus me-2"></i>Copiar data acima
                            </a></li>
                            <li><a class="dropdown-item text-danger" href="#" onclick="event.preventDefault(); excluirLinha(${index})">
                                <i class="bi bi-trash me-2"></i>Excluir linha
                            </a></li>
                        </ul>
                    </div>
                </td>
            `);
            
            // OTIMIZAÇÃO 2: Lazy loading para Notas Fiscais
            // Só processar se linha tem ID (linha salva no banco), evita lookup desnecessário
            if (secaoNotasFiscaisAtiva) {
                const nf = linha.id && notasFiscais[linha.id] ? notasFiscais[linha.id] : { numero_nota: '', chave_acesso: '', cnpj_nota: '' };
                const cnpjInvalido = nf.cnpj_nota && nf.cnpj_nota.replace(/\D/g, '').length !== 14;
                
                htmlParts.push(`
                    <!-- Coluna 11: Número da Nota -->
                    <td class="col-nf">
                        <input type="number" 
                               class="cell-input" 
                               value="${nf.numero_nota || ''}" 
                               onchange="atualizarCampoNF(${index}, 'numero_nota', this.value)"
                               onkeydown="navegarCelulaNF(event, ${index}, 0)"
                               placeholder="Número..."
                               autocomplete="off">
                    </td>
                    <!-- Coluna 12: Chave de Acesso -->
                    <td class="col-nf">
                        <input type="text" 
                               class="cell-input" 
                               value="${nf.chave_acesso || ''}" 
                               onchange="atualizarCampoNF(${index}, 'chave_acesso', this.value)"
                               onkeydown="navegarCelulaNF(event, ${index}, 1)"
                               placeholder="Chave de acesso..."
                               autocomplete="off">
                    </td>
                    <!-- Coluna 13: CNPJ -->
                    <td class="col-nf ${cnpjInvalido ? 'cnpj-invalido' : ''}">
                        <input type="text" 
                               class="cell-input" 
                               value="${nf.cnpj_nota || ''}" 
                               onchange="atualizarCampoNF(${index}, 'cnpj_nota', this.value)"
                               onkeydown="navegarCelulaNF(event, ${index}, 2)"
                               placeholder="00.000.000/0001-00"
                               autocomplete="off">
                    </td>
                `);
            }
            
            // OTIMIZAÇÃO 2: Lazy loading para Documentos
            // Só processar se linha tem ID, calcular regras sob demanda apenas quando necessário
            if (secaoDocumentosAtiva) {
                const doc = linha.id && documentosAnalise[linha.id] ? documentosAnalise[linha.id] : {};
                
                // Calcular aplicabilidade apenas se linha tem categoria
                const categoria = linha.cat_transacao || '';
                const naoAplicavelGeral = categoria ? (categoriasAplicabilidade[categoria] === true) : false;
                
                // Calcular regras específicas apenas se necessário
                const rubrica = categoria && categoriasRubricas[categoria] ? categoriasRubricas[categoria] : '';
                
                // REGRA: "Fora do Município" - não aplicável para Pessoal e Administrativas
                const naoAplicavelForaMunicipio = naoAplicavelGeral || 
                    rubrica === 'Pessoal' || rubrica === 'Administrativas';
                
                // REGRA: "Contratos" - não aplicável para Pessoal, Materiais, Implantação e Imobilizado
                const rubricasSemContrato = ['Pessoal', 'Materiais', 'Implantação', 'Imobilizado'];
                const naoAplicavelContratos = naoAplicavelGeral || rubricasSemContrato.includes(rubrica);
                
                // Usar valores direto do objeto documentosAnalise (já migrados no carregamento)
                // MAS: se categoria não aplicável, forçar vazio para mostrar "Selecione..."
                const valorGuia = naoAplicavelGeral ? '' : (doc.avaliacao_guia || '');
                const valorComprovante = naoAplicavelGeral ? '' : (doc.avaliacao_comprovante || '');
                const valorContratos = naoAplicavelContratos ? '' : (doc.avaliacao_contratos || '');
                const valorForaMunicipio = naoAplicavelForaMunicipio ? '' : (doc.avaliacao_fora_municipio || '');
                
                htmlParts.push(`
                    <!-- Coluna 14: Guia -->
                    <td class="col-doc ${naoAplicavelGeral ? 'cell-disabled' : ''}">
                        <select class="form-select form-select-sm" 
                                ${naoAplicavelGeral ? 'disabled' : ''}
                                onchange="atualizarCampoDoc(${index}, 'avaliacao_guia', this.value)"
                                style="cursor: ${naoAplicavelGeral ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;">
                            <option value="" ${!valorGuia || valorGuia === '' ? 'selected' : ''}>Selecione...</option>
                            <option value="Guia apresentada" ${valorGuia === 'Guia apresentada' ? 'selected' : ''}>Guia apresentada</option>
                            <option value="Guia apresentada (cliente divergente)" ${valorGuia === 'Guia apresentada (cliente divergente)' ? 'selected' : ''}>Guia apresentada (cliente divergente)</option>
                            <option value="Guia apresentada (destinatário não identificado)" ${valorGuia === 'Guia apresentada (destinatário não identificado)' ? 'selected' : ''}>Guia apresentada (destinatário não identificado)</option>
                            <option value="Não apresentada" ${valorGuia === 'Não apresentada' ? 'selected' : ''}>Não apresentada</option>
                        </select>
                    </td>
                    <!-- Coluna 15: Comprovante -->
                    <td class="col-doc ${naoAplicavelGeral ? 'cell-disabled' : ''}">
                        <select class="form-select form-select-sm" 
                                ${naoAplicavelGeral ? 'disabled' : ''}
                                onchange="atualizarCampoDoc(${index}, 'avaliacao_comprovante', this.value)"
                                style="cursor: ${naoAplicavelGeral ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;">
                            <option value="" ${!valorComprovante || valorComprovante === '' ? 'selected' : ''}>Selecione...</option>
                            <option value="Apresentado corretamente" ${valorComprovante === 'Apresentado corretamente' ? 'selected' : ''}>Apresentado corretamente</option>
                            <option value="Não apresentado" ${valorComprovante === 'Não apresentado' ? 'selected' : ''}>Não apresentado</option>
                            <option value="Cartão de Crédito" ${valorComprovante === 'Cartão de Crédito' ? 'selected' : ''}>Cartão de Crédito</option>
                            <option value="Pago em Espécie" ${valorComprovante === 'Pago em Espécie' ? 'selected' : ''}>Pago em Espécie</option>
                            <option value="Pago em Cheque" ${valorComprovante === 'Pago em Cheque' ? 'selected' : ''}>Pago em Cheque</option>
                        </select>
                    </td>
                    <!-- Coluna 16: Contratos -->
                    <td class="col-doc ${naoAplicavelContratos ? 'cell-disabled' : ''}">
                        <select class="form-select form-select-sm" 
                                ${naoAplicavelContratos ? 'disabled' : ''}
                                onchange="atualizarCampoDoc(${index}, 'avaliacao_contratos', this.value)"
                                style="cursor: ${naoAplicavelContratos ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;">
                            <option value="" ${!valorContratos || valorContratos === '' ? 'selected' : ''}>Selecione...</option>
                            <option value="Contratos apresentados" ${valorContratos === 'Contratos apresentados' ? 'selected' : ''}>Contratos apresentados</option>
                            <option value="Não apresentado" ${valorContratos === 'Não apresentado' ? 'selected' : ''}>Não apresentado</option>
                        </select>
                    </td>
                    <!-- Coluna 17: Fora Município -->
                    <td class="col-doc ${naoAplicavelForaMunicipio ? 'cell-disabled' : ''}">
                        <select class="form-select form-select-sm" 
                                ${naoAplicavelForaMunicipio ? 'disabled' : ''}
                                onchange="atualizarCampoDoc(${index}, 'avaliacao_fora_municipio', this.value)"
                                style="cursor: ${naoAplicavelForaMunicipio ? 'not-allowed' : 'pointer'}; font-size: 0.875rem;">
                            <option value="" ${!valorForaMunicipio || valorForaMunicipio === '' ? 'selected' : ''}>Selecione...</option>
                            <option value="São Paulo" ${valorForaMunicipio === 'São Paulo' ? 'selected' : ''}>São Paulo</option>
                            <option value="Fora do município" ${valorForaMunicipio === 'Fora do município' ? 'selected' : ''}>Fora do município</option>
                        </select>
                    </td>
                `);
            }
            
            // OTIMIZAÇÃO CRÍTICA: Parse único com join()
            tr.innerHTML = htmlParts.join('');
            
            // OTIMIZAÇÃO: Adicionar ao fragment (não dispara reflow)
            fragment.appendChild(tr);
        });
        
        performanceMetrics.end(timerFiltro);
        
        // OTIMIZAÇÃO: Limpar tbody e adicionar fragment de uma vez (1 único reflow)
        const timerDOM = performanceMetrics.start('renderizarTabela - Atualizar DOM');
        tbody.innerHTML = '';
        tbody.appendChild(fragment);
        performanceMetrics.end(timerDOM);
        
        // DEBOUNCE: Pular atualização de filtros se flag ativada (reduz renders desnecessários)
        if (!skipFilters) {
            const timerFiltros = performanceMetrics.start('renderizarTabela - Popular filtros');
            popularFiltros();
            atualizarDatalistOrigemDestino();
            atualizarDatalistObservacoes();
            performanceMetrics.end(timerFiltros);
            
            const timerReaplicar = performanceMetrics.start('renderizarTabela - Reaplicar filtros');
            aplicarFiltros();
            performanceMetrics.end(timerReaplicar);
        }
        
        performanceMetrics.end(timerTotal);
        
        console.log(`%c[RENDER] ${linhasFiltradas.length} linhas renderizadas`, 'color: purple; font-weight: bold');
    }
    
    // Adicionar listener para colar do Excel
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('tabelaConciliacao').addEventListener('paste', function(e) {
            const target = e.target;
            
            // Verificar se está em um input da tabela
            if (!target.classList.contains('cell-input') && !target.classList.contains('cell-money')) {
                return;
            }
            
            e.preventDefault();
            
            // Pegar dados do clipboard
            const clipboardData = e.clipboardData || window.clipboardData;
            const pastedData = clipboardData.getData('Text');
            
            if (!pastedData) return;
            
            // Encontrar índice da linha e coluna atual
            const tr = target.closest('tr');
            const linhaIndex = parseInt(tr.dataset.index);
            
            // Determinar coluna atual
            const td = target.closest('td');
            const allTds = Array.from(tr.children);
            const tdIndex = allTds.indexOf(td);
            
            // Verificar se está em coluna de Notas Fiscais
            if (td.classList.contains('col-nf')) {
                // PASTE em colunas de NF
                const colunasNF = ['numero_nota', 'chave_acesso', 'cnpj_nota'];
                const inputsNF = Array.from(tr.querySelectorAll('.col-nf input'));
                const colunaInicialNF = inputsNF.indexOf(target);
                
                if (colunaInicialNF === -1) return;
                
                // Parse dos dados
                const linhasPaste = pastedData
                    .split('\n')
                    .filter(l => l !== '')  // Remover apenas linhas completamente vazias (não trim!)
                    .map(l => l.split('\t'));  // Split preserva células vazias como ''
                
                if (linhasPaste.length === 0) return;
                
                // Salvar estado antes de modificar
                salvarEstadoNoHistorico();
                
                // Garantir linhas suficientes
                const linhasNecessarias = linhaIndex + linhasPaste.length;
                while (linhas.length < linhasNecessarias) {
                    adicionarLinha();
                }
                
                // Distribuir dados de NF
                linhasPaste.forEach((dadosLinha, rowOffset) => {
                    const targetLinhaIdx = linhaIndex + rowOffset;
                    const linha = linhas[targetLinhaIdx];
                    
                    if (!linha.id) return; // Pular se linha não salva ainda
                    
                    if (!notasFiscais[linha.id]) {
                        notasFiscais[linha.id] = { numero_nota: '', chave_acesso: '', cnpj_nota: '' };
                    }
                    
                    dadosLinha.forEach((valor, colOffset) => {
                        const colunaIdx = colunaInicialNF + colOffset;
                        if (colunaIdx < colunasNF.length) {
                            const campo = colunasNF[colunaIdx];
                            notasFiscais[linha.id][campo] = valor.trim();
                        }
                    });
                });
                
                renderizarTabela();
                agendarAutosave();
                alert(`✓ ${linhasPaste.length} linha(s) de NF coladas!`);
                return;
            }
            
            // Mapear índice de TD para campo (EXTRATO)
            // 0=índice, 1=data, 2=crédito, 3=débito, 4=composição, 5=categoria, 6=competência, 7=origem, 8=avaliação, 9=observações, 10=ações
            const colunaMap = {
                1: 'data',
                2: 'credito',
                3: 'debito',
                4: 'discriminacao',
                5: 'cat_transacao',
                6: 'competencia',
                7: 'origem_destino',
                8: 'cat_avaliacao',
                9: 'avaliacao_analista'
            };
            
            const colunaInicial = colunaMap[tdIndex];
            if (!colunaInicial) return;
            
            // Salvar estado antes de modificar
            salvarEstadoNoHistorico();
            
            // Parse dos dados (Excel copia com \t para colunas e \n para linhas)
            const linhasPaste = pastedData
                .split('\n')
                .filter(l => l !== '')  // Remover apenas linhas completamente vazias (não trim!)
                .map(l => l.split('\t'));  // Split preserva células vazias como ''
            
            // Se não há linhas válidas, retornar
            if (linhasPaste.length === 0) return;
            
            // Garantir que temos linhas suficientes
            const linhasNecessarias = linhaIndex + linhasPaste.length;
            while (linhas.length < linhasNecessarias) {
                adicionarLinha();
            }
            
            // Distribuir dados
            const colunasOrdem = ['data', 'credito', 'debito', 'discriminacao', 'cat_transacao', 'competencia', 'origem_destino', 'cat_avaliacao', 'avaliacao_analista'];
            const colunaInicialIdx = colunasOrdem.indexOf(colunaInicial);
            
            linhasPaste.forEach((dadosLinha, rowOffset) => {
                const targetLinhaIdx = linhaIndex + rowOffset;
                if (targetLinhaIdx >= linhas.length) return;
                
                dadosLinha.forEach((valor, colOffset) => {
                    const colunaIdx = colunaInicialIdx + colOffset;
                    if (colunaIdx >= colunasOrdem.length) return;
                    
                    const campo = colunasOrdem[colunaIdx];
                    valor = valor.trim();
                    
                    if (campo === 'credito' || campo === 'debito' || campo === 'discriminacao') {
                        // Converter para número (ou null se vazio)
                        const valorNumerico = valor ? parseMoeda(valor) : null;
                        linhas[targetLinhaIdx][campo] = valorNumerico;
                    } else if (campo === 'data') {
                        // Tentar converter data (dd/mm/aaaa ou dd/mm/aa)
                        if (valor && valor.includes('/')) {
                            const partes = valor.split('/');
                            if (partes.length === 3) {
                                let dia = partes[0].padStart(2, '0');
                                let mes = partes[1].padStart(2, '0');
                                let ano = partes[2];
                                
                                // Converter ano de 2 dígitos para 4
                                if (ano.length === 2) {
                                    ano = '20' + ano;
                                }
                                
                                // Formato aaaa-mm-dd
                                linhas[targetLinhaIdx][campo] = `${ano}-${mes}-${dia}`;
                            } else {
                                linhas[targetLinhaIdx][campo] = valor;
                            }
                        } else {
                            // Se vazio ou não tem '/', atribuir vazio ou o valor original
                            linhas[targetLinhaIdx][campo] = valor || '';
                        }
                    } else if (campo === 'competencia') {
                        // Parse competência (mai/2025, 05/2025, 01/06/2017, etc)
                        if (valor) {
                            const competenciaParsed = parseCompetencia(valor);
                            if (competenciaParsed) {
                                linhas[targetLinhaIdx][campo] = competenciaParsed;
                            } else {
                                linhas[targetLinhaIdx][campo] = valor;
                            }
                        } else {
                            // Célula vazia - atribuir vazio
                            linhas[targetLinhaIdx][campo] = '';
                        }
                    } else {
                        linhas[targetLinhaIdx][campo] = valor;
                    }
                });
            });
            
            renderizarTabela();
            document.getElementById('btnSalvar').style.display = 'block';
            agendarAutosave();
            
            alert(`✓ ${linhasPaste.length} linha(s) e ${linhasPaste[0].length} coluna(s) coladas com sucesso!`);
        });
    });

    function verificarMesclagem(index) {
        if (index === 0) return false;
        
        const linhaAtual = linhas[index];
        const linhaAnterior = linhas[index - 1];
        
        // Verifica se tem o mesmo valor de débito ou crédito
        const mesmoDebito = linhaAtual.debito && linhaAnterior.debito && 
                           parseFloat(linhaAtual.debito) === parseFloat(linhaAnterior.debito);
        const mesmoCredito = linhaAtual.credito && linhaAnterior.credito && 
                            parseFloat(linhaAtual.credito) === parseFloat(linhaAnterior.credito);
        
        return mesmoDebito || mesmoCredito;
    }
    
    function getGrupoMesclagem(index) {
        // Sistema manual de mesclagem: verifica array mesclado_com
        const linha = linhas[index];
        if (!linha.mesclado_com || linha.mesclado_com.length === 0) return null;
        
        // Esta linha é a principal (primeira) do grupo
        return {
            inicio: index,
            fim: Math.max(...linha.mesclado_com),
            tamanho: linha.mesclado_com.length + 1,
            isPrimeira: true,
            isUltima: false,
            indices: [index, ...linha.mesclado_com]
        };
    }
    
    function linhaEstaMescladaComoSecundaria(index) {
        // Verifica se esta linha está mesclada como secundária (parte de outro grupo)
        return linhas.some((l, i) => i < index && l.mesclado_com && l.mesclado_com.includes(index));
    }

    function atualizarCampo(index, campo, valor) {
        linhas[index][campo] = valor;
        
        // Rastrear deleção manual de competência
        if (campo === 'competencia') {
            if (!valor || valor.trim() === '') {
                // Usuário deletou a competência - marcar para não auto-preencher
                linhas[index]._competencia_deletada = true;
            } else {
                // Usuário preencheu - remover flag
                delete linhas[index]._competencia_deletada;
            }
        }
        
        agendarAutosave();
    }
    
    function atualizarCampoData(index, valor) {
        // Converter dd/mm/aaaa para aaaa-mm-dd
        let dataFormatada = valor;
        
        if (valor && valor.includes('/')) {
            const partes = valor.split('/');
            if (partes.length === 3) {
                const dia = partes[0].padStart(2, '0');
                const mes = partes[1].padStart(2, '0');
                let ano = partes[2];
                
                // Converter ano de 2 dígitos para 4
                if (ano.length === 2) {
                    ano = '20' + ano;
                }
                
                dataFormatada = `${ano}-${mes}-${dia}`;
            }
        }
        
        atualizarCampo(index, 'data', dataFormatada);
        
        // Auto-preencher competência apenas se:
        // 1. Data foi preenchida
        // 2. Competência ainda não foi deletada/editada manualmente
        if (dataFormatada && !linhas[index]._competencia_deletada) {
            const competenciaAuto = calcularCompetenciaAutomatica(dataFormatada);
            if (competenciaAuto) {
                linhas[index].competencia = competenciaAuto;
                linhas[index].competencia_valida = true;
                console.log(`Auto-preenchimento: competência = ${formatarCompetenciaParaExibicao(competenciaAuto)}`);
            }
        }
    }
    
    function navegarCelulaData(event, linhaIndex) {
        const input = event.target;
        
        // Enter: vai para baixo
        if (event.key === 'Enter') {
            event.preventDefault();
            
            // Formatar data antes de sair (se tiver valor parcial)
            const valor = input.value;
            if (valor && !valor.includes('-')) {
                atualizarCampoData(linhaIndex, valor);
            }
            
            focarCelula(linhaIndex + 1, 0);
            return;
        }
        
        // Tab: vai para direita
        if (event.key === 'Tab' && !event.ctrlKey) {
            event.preventDefault();
            
            // Formatar data antes de sair
            const valor = input.value;
            if (valor && !valor.includes('-')) {
                atualizarCampoData(linhaIndex, valor);
            }
            
            focarCelula(linhaIndex, 1);
            return;
        }
        
        // Ctrl+Tab: vai para esquerda
        if (event.key === 'Tab' && event.ctrlKey) {
            event.preventDefault();
            focarCelula(linhaIndex, -1);
            return;
        }
        
        // Auto-adicionar barras ao digitar data
        if (event.key >= '0' && event.key <= '9') {
            const valor = input.value.replace(/\D/g, '');
            if (valor.length === 2 || valor.length === 4) {
                setTimeout(() => {
                    const atual = input.value.replace(/\D/g, '');
                    if (atual.length === 2) {
                        input.value = atual.slice(0, 2) + '/';
                    } else if (atual.length === 4) {
                        input.value = atual.slice(0, 2) + '/' + atual.slice(2, 4) + '/';
                    }
                }, 10);
            }
        }
    }

    function navegarCelulaOrigemDestino(event, linhaIndex) {
        // Enter: vai para próxima linha, mesma coluna (Origem/Destino)
        if (event.key === 'Enter') {
            event.preventDefault();
            focarCelula(linhaIndex + 1, 6);
            return;
        }
        
        // Tab: vai para direita (Avaliação)
        if (event.key === 'Tab' && !event.ctrlKey) {
            event.preventDefault();
            focarCelula(linhaIndex, 7);
            return;
        }
        
        // Ctrl+Tab: vai para esquerda (Competência)
        if (event.key === 'Tab' && event.ctrlKey) {
            event.preventDefault();
            focarCelula(linhaIndex, 5);
            return;
        }
    }
    
    function atualizarCampoNF(index, campo, valor) {
        const linha = linhas[index];
        if (!linha.id) {
            console.warn('Linha não salva ainda - NF será criada após salvar extrato');
            return;
        }
        
        // Criar objeto NF se não existir
        if (!notasFiscais[linha.id]) {
            notasFiscais[linha.id] = {
                numero_nota: '',
                chave_acesso: '',
                cnpj_nota: ''
            };
        }
        
        notasFiscais[linha.id][campo] = valor;
        
        // Re-renderizar para validar CNPJ
        if (campo === 'cnpj_nota') {
            renderizarTabela();
        }
        
        agendarAutosave();
    }
    
    function atualizarCampoDoc(index, campo, valorDropdown) {
        const linha = linhas[index];
        if (!linha.id) {
            console.warn('Linha não salva ainda - Documentos serão criados após salvar extrato');
            return;
        }
        
        // Criar objeto Documentos se não existir
        if (!documentosAnalise[linha.id]) {
            documentosAnalise[linha.id] = {
                avaliacao_guia: '',
                avaliacao_comprovante: '',
                avaliacao_contratos: '',
                avaliacao_fora_municipio: ''
            };
        }
        
        // Atualizar campo com valor do dropdown (texto direto)
        documentosAnalise[linha.id][campo] = valorDropdown || '';
        
        agendarAutosave();
    }
    
    function navegarCelulaNF(event, linhaIndex, colunaAtual) {
        // colunaAtual: 0 = numero_nota, 1 = chave_acesso, 2 = cnpj_nota
        
        // Enter: vai para baixo na mesma coluna
        if (event.key === 'Enter') {
            event.preventDefault();
            if (linhaIndex < linhas.length - 1) {
                const proximaLinha = linhaIndex + 1;
                const inputs = document.querySelectorAll(`tr[data-index="${proximaLinha}"] .col-nf input`);
                if (inputs[colunaAtual]) {
                    inputs[colunaAtual].focus();
                    inputs[colunaAtual].select();
                }
            }
            return;
        }
        
        // Tab: vai para direita
        if (event.key === 'Tab' && !event.ctrlKey) {
            event.preventDefault();
            const inputs = document.querySelectorAll(`tr[data-index="${linhaIndex}"] .col-nf input`);
            if (colunaAtual < 2) {
                // Próxima coluna de NF
                inputs[colunaAtual + 1].focus();
                inputs[colunaAtual + 1].select();
            } else {
                // Última coluna NF - ir para próxima linha, primeira coluna NF
                if (linhaIndex < linhas.length - 1) {
                    const proximaLinha = linhaIndex + 1;
                    const inputsProxima = document.querySelectorAll(`tr[data-index="${proximaLinha}"] .col-nf input`);
                    if (inputsProxima[0]) {
                        inputsProxima[0].focus();
                        inputsProxima[0].select();
                    }
                }
            }
            return;
        }
        
        // Ctrl+Tab: vai para esquerda
        if (event.key === 'Tab' && event.ctrlKey) {
            event.preventDefault();
            const inputs = document.querySelectorAll(`tr[data-index="${linhaIndex}"] .col-nf input`);
            if (colunaAtual > 0) {
                // Coluna anterior de NF
                inputs[colunaAtual - 1].focus();
                inputs[colunaAtual - 1].select();
            } else {
                // Primeira coluna NF - voltar para última coluna do extrato (Observações)
                focarCelula(linhaIndex, 8);
            }
            return;
        }
    }

    function identificarGrupoComposicao(index) {
        // Identifica se a linha faz parte de um grupo de composição
        // Retorna: { ehGrupo: boolean, ehPrimeira: boolean, inicioGrupo: number, fimGrupo: number, tipo: 'credito'|'debito' }
        
        const linha = linhas[index];
        const valorReferencia = linha.credito || linha.debito;
        
        if (!valorReferencia) {
            return { ehGrupo: false };
        }
        
        // Se composição = valor (débito/crédito), não faz parte de grupo composto
        const composicao = linha.discriminacao || 0;
        if (Math.abs(composicao - valorReferencia) < 0.01) {
            return { ehGrupo: false };
        }
        
        const data = linha.data;
        const tipo = linha.credito ? 'credito' : 'debito';
        
        // Buscar início do grupo (para trás)
        // Apenas linhas com composição DIFERENTE do valor principal
        let inicioGrupo = index;
        for (let i = index - 1; i >= 0; i--) {
            const linhaAnterior = linhas[i];
            const valorAnterior = tipo === 'credito' ? linhaAnterior.credito : linhaAnterior.debito;
            const composicaoAnterior = linhaAnterior.discriminacao || 0;
            
            // Verificar: mesma data, mesmo valor, composição ≠ valor
            if (linhaAnterior.data === data && 
                Math.abs((valorAnterior || 0) - valorReferencia) < 0.01 &&
                Math.abs(composicaoAnterior - valorReferencia) >= 0.01) {
                inicioGrupo = i;
            } else {
                break;
            }
        }
        
        // Buscar fim do grupo (para frente)
        // Apenas linhas com composição DIFERENTE do valor principal
        let fimGrupo = index;
        for (let i = index + 1; i < linhas.length; i++) {
            const linhaPosterior = linhas[i];
            const valorPosterior = tipo === 'credito' ? linhaPosterior.credito : linhaPosterior.debito;
            const composicaoPosterior = linhaPosterior.discriminacao || 0;
            
            // Verificar: mesma data, mesmo valor, composição ≠ valor
            if (linhaPosterior.data === data && 
                Math.abs((valorPosterior || 0) - valorReferencia) < 0.01 &&
                Math.abs(composicaoPosterior - valorReferencia) >= 0.01) {
                fimGrupo = i;
            } else {
                break;
            }
        }
        
        // Se há apenas 1 linha, não é grupo
        if (inicioGrupo === fimGrupo) {
            return { ehGrupo: false };
        }
        
        // É um grupo válido!
        // (composições podem ser iguais ou diferentes, o importante é que composição ≠ valor)
        return {
            ehGrupo: true,
            ehPrimeira: index === inicioGrupo,
            inicioGrupo: inicioGrupo,
            fimGrupo: fimGrupo,
            tipo: tipo
        };
    }

    function validarComposicao(index) {
        // Validar composição com base em grupos (exclui linhas onde composição = valor)
        
        const linha = linhas[index];
        const valorReferencia = linha.credito || linha.debito;
        const composicao = linha.discriminacao;
        
        if (!valorReferencia) {
            return true; // Sem valor de referência, não validar
        }
        
        if (!composicao) {
            return true; // Sem composição ainda, não invalidar
        }
        
        // Se composição = valor, validação individual simples
        if (Math.abs(composicao - valorReferencia) < 0.01) {
            return true; // Composição igual ao valor é sempre válida
        }
        
        // Usar função de identificação de grupo (que já exclui linhas com composição = valor)
        const grupoInfo = identificarGrupoComposicao(index);
        
        if (!grupoInfo.ehGrupo) {
            // Linha individual com composição ≠ valor
            // Pode ser válida se houver linhas adjacentes com mesmo valor/data (grupo em formação)
            // Validar como grupo potencial antes de invalidar
            const data = linha.data;
            const tipo = linha.credito ? 'credito' : 'debito';
            
            // Verificar se há linhas adjacentes com mesmo valor e data (grupo potencial)
            let temAdjacentes = false;
            
            // Verificar linha anterior
            if (index > 0) {
                const linhaAnt = linhas[index - 1];
                const valorAnt = tipo === 'credito' ? linhaAnt.credito : linhaAnt.debito;
                if (linhaAnt.data === data && Math.abs((valorAnt || 0) - valorReferencia) < 0.01) {
                    temAdjacentes = true;
                }
            }
            
            // Verificar linha posterior
            if (index < linhas.length - 1) {
                const linhaPost = linhas[index + 1];
                const valorPost = tipo === 'credito' ? linhaPost.credito : linhaPost.debito;
                if (linhaPost.data === data && Math.abs((valorPost || 0) - valorReferencia) < 0.01) {
                    temAdjacentes = true;
                }
            }
            
            // Se tem adjacentes, considerar válida (grupo em formação)
            // Se não tem adjacentes, considerar inválida (composição diferente sem grupo)
            return temAdjacentes;
        }
        
        // Linha faz parte de grupo: somar todas as composições do grupo
        const composicoesGrupo = [];
        for (let i = grupoInfo.inicioGrupo; i <= grupoInfo.fimGrupo; i++) {
            composicoesGrupo.push(linhas[i].discriminacao || 0);
        }
        
        const somaComposicoes = composicoesGrupo.reduce((acc, val) => acc + val, 0);
        const diferenca = Math.abs(valorReferencia - somaComposicoes);
        
        return diferenca <= 0.02;
    }

    function validarComposicao_OLD_BACKUP(index) {
        // BACKUP da lógica antiga - manter para referência
        const linha = linhas[index];
        const valorReferencia = linha.credito || linha.debito;
        const composicao = linha.discriminacao;
        
        if (!valorReferencia) {
            return true;
        }
        
        if (!composicao) {
            return true;
        }
        
        const data = linha.data;
        const tipo = linha.credito ? 'credito' : 'debito';
        
        // Buscar início do grupo (para trás)
        let inicioGrupo = index;
        for (let i = index - 1; i >= 0; i--) {
            const linhaAnterior = linhas[i];
            const valorAnterior = tipo === 'credito' ? linhaAnterior.credito : linhaAnterior.debito;
            
            // Se for mesma data e mesmo valor, faz parte do grupo
            if (linhaAnterior.data === data && Math.abs((valorAnterior || 0) - valorReferencia) < 0.01) {
                inicioGrupo = i;
            } else {
                break; // Linha diferente, fim do grupo
            }
        }
        
        // Buscar fim do grupo (para frente)
        let fimGrupo = index;
        for (let i = index + 1; i < linhas.length; i++) {
            const linhaPosterior = linhas[i];
            const valorPosterior = tipo === 'credito' ? linhaPosterior.credito : linhaPosterior.debito;
            
            // Se for mesma data e mesmo valor, faz parte do grupo
            if (linhaPosterior.data === data && Math.abs((valorPosterior || 0) - valorReferencia) < 0.01) {
                fimGrupo = i;
            } else {
                break; // Linha diferente, fim do grupo
            }
        }
        
        // Se há apenas 1 linha no grupo, validar normalmente (1-1)
        if (inicioGrupo === fimGrupo) {
            const diferenca = Math.abs(valorReferencia - composicao);
            return diferenca <= 0.02;
        }
        
        // Grupo com 2+ linhas: verificar se as composições são DIFERENTES
        const composicoesGrupo = [];
        for (let i = inicioGrupo; i <= fimGrupo; i++) {
            composicoesGrupo.push(linhas[i].discriminacao || 0);
        }
        
        // Se todas composições forem iguais, validar como 1-1
        const todasIguais = composicoesGrupo.every(comp => Math.abs(comp - composicoesGrupo[0]) < 0.01);
        if (todasIguais) {
            const diferenca = Math.abs(valorReferencia - composicao);
            return diferenca <= 0.02;
        }
        
        // Composições diferentes: somar e validar o total
        const somaComposicoes = composicoesGrupo.reduce((acc, val) => acc + val, 0);
        const diferenca = Math.abs(valorReferencia - somaComposicoes);
        
        return diferenca <= 0.02;
    }

    function atualizarValor(index, campo, valor) {
        const valorNumerico = parseMoeda(valor);
        const linhaAnterior = linhas[index][campo];
        linhas[index][campo] = valorNumerico;
        
        // Auto-preencher composição apenas na PRIMEIRA vez que crédito/débito for preenchido
        // (se composição ainda está vazia ou não foi editada manualmente)
        if ((campo === 'credito' || campo === 'debito') && valorNumerico) {
            const composicaoAtual = linhas[index].discriminacao;
            
            // Se composição está vazia OU nunca foi editada manualmente
            if (!composicaoAtual && !linhas[index]._composicao_editada) {
                linhas[index].discriminacao = valorNumerico;
                console.log(`Auto-preenchimento: composição = ${valorNumerico}`);
            }
        }
        
        // Não renderizar toda tabela no onchange, apenas no onblur
        agendarAutosave();
    }
    
    function verificarAutoPreenchimento(index) {
        // Marcar que composição foi editada manualmente
        linhas[index]._composicao_editada = true;
        
        // Renderizar apenas uma vez após todas as atualizações
        renderizarTabela();
    }
    
    function verificarAutoPreenchimentoCategoria(index) {
        const linha = linhas[index];
        const categoria = linha.cat_transacao;
        
        if (categoria) {
            // Buscar correspondente da categoria selecionada
            const categoriaObj = categoriasAnalise.find(cat => cat.categoria_extra === categoria);
            if (categoriaObj && categoriaObj.correspondente) {
                let origemDestino = categoriaObj.correspondente;
                
                // Se o correspondente for "Banco", substituir pelo banco atual do termo
                if (origemDestino === 'Banco' && bancoAtual) {
                    origemDestino = bancoAtual;
                }
                
                // Preencher apenas se o campo estiver vazio
                if (!linha.origem_destino) {
                    linha.origem_destino = origemDestino;
                }
            }
        }
        
        // Renderizar após atualização
        renderizarTabela();
    }

    function formatarMoeda(valor) {
        if (!valor || valor === 0) return '';
        return new Intl.NumberFormat('pt-BR', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(valor);
    }

    function formatarCampoMoeda(input) {
        const valor = parseMoeda(input.value);
        if (valor !== null && valor !== 0) {
            input.value = formatarMoeda(valor);
        }
    }

    function parseMoeda(valor) {
        if (!valor) return null;
        
        // Converter para string e remover símbolos de moeda e espaços
        let valorStr = String(valor).trim();
        
        // Detectar formato brasileiro (1.234,56) vs americano (1,234.56)
        // Se houver vírgula E ponto, o último caractere define o decimal
        const temVirgula = valorStr.includes(',');
        const temPonto = valorStr.includes('.');
        
        if (temVirgula && temPonto) {
            // Tem ambos: descobrir qual é o decimal pelo último
            const ultimaVirgula = valorStr.lastIndexOf(',');
            const ultimoPonto = valorStr.lastIndexOf('.');
            
            if (ultimaVirgula > ultimoPonto) {
                // Formato brasileiro: 1.234,56
                valorStr = valorStr.replace(/\./g, '').replace(',', '.');
            } else {
                // Formato americano: 1,234.56
                valorStr = valorStr.replace(/,/g, '');
            }
        } else if (temVirgula) {
            // Só vírgula: assumir formato brasileiro
            valorStr = valorStr.replace(/\./g, '').replace(',', '.');
        }
        // Se só tem ponto, já está no formato correto
        
        // Remover tudo exceto números, ponto e sinal negativo
        valorStr = valorStr.replace(/[^\d.-]/g, '');
        
        return parseFloat(valorStr) || null;
    }
    
    function blurCondicional(index, input) {
        // Apenas formatar a moeda
        formatarCampoMoeda(input);
        
        // REMOVIDO: Auto-preenchimento de composição
        // O usuário terá controle total sobre os valores
        
        // NÃO renderizar aqui - deixar para o usuário sair completamente da tabela
    }
    
    function blurCondicionalCategoria(index) {
        // Apenas atualizar dados, SEM renderizar
        const linha = linhas[index];
        const categoria = linha.cat_transacao;
        
        if (categoria) {
            const categoriaObj = categoriasAnalise.find(cat => cat.categoria_extra === categoria);
            if (categoriaObj && categoriaObj.correspondente) {
                let origemDestino = categoriaObj.correspondente;
                
                if (origemDestino === 'Banco' && bancoAtual) {
                    origemDestino = bancoAtual;
                }
                
                if (!linha.origem_destino) {
                    linha.origem_destino = origemDestino;
                }
            }
        }
        
        // NÃO renderizar aqui
    }
    
    function aplicarCorLinha(index) {
        // Aplicar cor à linha sem re-renderizar toda a tabela
        const tbody = document.getElementById('tbodyConciliacao');
        const tr = tbody.children[index];
        
        if (!tr) return;
        
        const linha = linhas[index];
        
        // Remover todas as classes de cor
        tr.classList.remove('avaliacao-avaliado', 'avaliacao-aguardando', 'avaliacao-pessoa-gestora', 'avaliacao-glosar');
        
        // Aplicar nova classe baseado na avaliação
        if (linha.cat_avaliacao === 'Avaliado') {
            tr.classList.add('avaliacao-avaliado');
        } else if (linha.cat_avaliacao === 'Aguardando resposta') {
            tr.classList.add('avaliacao-aguardando');
        } else if (linha.cat_avaliacao === 'Pessoa Gestora') {
            tr.classList.add('avaliacao-pessoa-gestora');
        } else if (linha.cat_avaliacao === 'Glosar') {
            tr.classList.add('avaliacao-glosar');
        }
    }

    function navegarCelula(event, linhaIndex, colunaAtual) {
        // Enter: vai para baixo (mesma coluna, próxima linha)
        if (event.key === 'Enter') {
            event.preventDefault();
            focarCelula(linhaIndex + 1, colunaAtual);
            return;
        }
        
        // Tab: vai para direita (próxima coluna, mesma linha)
        if (event.key === 'Tab' && !event.ctrlKey) {
            event.preventDefault();
            focarCelula(linhaIndex, colunaAtual + 1);
            return;
        }
        
        // Ctrl+Tab: vai para esquerda (coluna anterior, mesma linha)
        if (event.key === 'Tab' && event.ctrlKey) {
            event.preventDefault();
            focarCelula(linhaIndex, colunaAtual - 1);
            return;
        }
    }

    function focarCelula(linhaIndex, colunaIndex) {
        // Validar se a linha existe
        if (linhaIndex < 0 || linhaIndex >= linhas.length) {
            return;
        }
        
        // Mapeamento de colunas editáveis (índices baseados na ordem visual)
        // 0: data, 1: credito, 2: debito, 3: discriminacao, 4: categoria, 5: competencia, 6: origem_destino, 7: avaliacao, 8: observacoes
        const colunasEditaveis = ['data', 'credito', 'debito', 'discriminacao', 'categoria', 'competencia', 'origem_destino', 'avaliacao', 'observacoes'];
        
        // Validar coluna
        if (colunaIndex < 0 || colunaIndex >= colunasEditaveis.length) {
            return;
        }
        
        // Usar requestAnimationFrame para garantir que o DOM esteja pronto
        requestAnimationFrame(() => {
            const tbody = document.getElementById('tbodyConciliacao');
            const linhaElement = tbody.children[linhaIndex];
            
            if (!linhaElement) return;
            
            // Encontrar o input correspondente
            let inputSelector;
            const coluna = colunasEditaveis[colunaIndex];
            
            switch(coluna) {
                case 'data':
                    inputSelector = 'input[placeholder="dd/mm/aaaa"]';
                    break;
                case 'credito':
                case 'debito':
                case 'discriminacao':
                    // Pegar todos inputs tipo texto que são de moeda
                    const inputs = linhaElement.querySelectorAll('input.cell-money');
                    let targetInput;
                    if (coluna === 'credito') targetInput = inputs[0];
                    else if (coluna === 'debito') targetInput = inputs[1];
                    else if (coluna === 'discriminacao') targetInput = inputs[2];
                    
                    if (targetInput && !targetInput.disabled) {
                        targetInput.focus();
                        targetInput.select();
                    }
                    return;
                case 'categoria':
                    // Categoria usa datalist dinâmico, pegar o input que não é de avaliações nem origem/destino
                    const catInputs = linhaElement.querySelectorAll('input[type="text"][list]');
                    for (let inp of catInputs) {
                        const listId = inp.getAttribute('list');
                        if (listId && listId.startsWith('datalist-cat-')) {
                            if (!inp.disabled) {
                                inp.focus();
                                inp.select();
                            }
                            return;
                        }
                    }
                    return;
                case 'competencia':
                    inputSelector = 'input.competencia-input';
                    break;
                case 'origem_destino':
                    inputSelector = 'input[list="datalistOrigemDestino"]';
                    break;
                case 'avaliacao':
                    inputSelector = 'input[list="datalistAvaliacoes"]';
                    break;
                case 'observacoes':
                    inputSelector = 'input[placeholder="Observações..."]';
                    break;
            }
            
            if (inputSelector) {
                const input = linhaElement.querySelector(inputSelector);
                if (input && !input.disabled) {
                    input.focus();
                    input.select();
                }
            }
        });
    }

    function desmesclarLinha(index) {
        const linha = linhas[index];
        
        if (!linha.mesclado_com || linha.mesclado_com.length === 0) {
            alert('Esta linha não está mesclada.');
            return;
        }
        
        if (!confirm(`Desmesclar linha ${index + 1}?`)) {
            return;
        }
        
        // Limpar array de mesclagem
        linha.mesclado_com = [];
        
        renderizarTabela();
        document.getElementById('btnSalvar').style.display = 'block';
        agendarAutosave();
    }

    function copiarDataAcima(index) {
        if (index === 0) {
            alert('Esta é a primeira linha, não há data acima para copiar.');
            return;
        }
        
        // Encontrar a última linha com data preenchida (de trás para frente a partir da linha anterior)
        let linhaReferencia = -1;
        for (let i = index - 1; i >= 0; i--) {
            if (linhas[i].data) {
                linhaReferencia = i;
                break;
            }
        }
        
        if (linhaReferencia === -1) {
            alert('Não há nenhuma data preenchida nas linhas acima.');
            return;
        }
        
        const dataReferencia = linhas[linhaReferencia].data;
        const linhasAfetadas = index - linhaReferencia;
        
        // Preencher todas as linhas entre a referência e a atual
        for (let i = linhaReferencia + 1; i <= index; i++) {
            linhas[i].data = dataReferencia;
            
            // Auto-preencher competência baseada na data copiada
            if (!linhas[i].competencia) {
                linhas[i].competencia = calcularCompetenciaAutomatica(dataReferencia);
            }
        }
        
        renderizarTabela();
    }
    
    function formatarDataParaExibicao(dataStr) {
        if (!dataStr) return '';
        // Converter aaaa-mm-dd para dd/mm/aaaa
        const partes = dataStr.split('-');
        if (partes.length === 3) {
            return `${partes[2]}/${partes[1]}/${partes[0]}`;
        }
        return dataStr;
    }

    function popularFiltros() {
        const timerPopular = performanceMetrics.start('popularFiltros - TOTAL');
        
        // Popular filtro de datas (por mês/ano)
        const selectData = document.getElementById('filtroData');
        const datasUnicas = new Set();
        
        linhas.forEach(linha => {
            if (linha.data) {
                // Extrair mês/ano (formato: aaaa-mm-dd -> mm/aaaa)
                const partes = linha.data.split('-');
                if (partes.length === 3) {
                    const mesAno = `${partes[1]}/${partes[0]}`;
                    datasUnicas.add(mesAno);
                }
            }
        });
        
        selectData.innerHTML = '<option value="">Todas as datas</option>';
        [...datasUnicas].sort().forEach(data => {
            const option = document.createElement('option');
            option.value = data;
            option.textContent = data;
            selectData.appendChild(option);
        });
        
        // Popular filtro de competências
        const selectCompetencia = document.getElementById('filtroCompetencia');
        const competenciasUnicas = new Set();
        
        linhas.forEach(linha => {
            if (linha.competencia) {
                const competenciaFormatada = formatarCompetenciaParaExibicao(linha.competencia);
                competenciasUnicas.add(competenciaFormatada);
            }
        });
        
        selectCompetencia.innerHTML = '<option value="">Todas as competências</option>';
        [...competenciasUnicas].sort().forEach(comp => {
            const option = document.createElement('option');
            option.value = comp;
            option.textContent = comp;
            selectCompetencia.appendChild(option);
        });
        
        // Popular filtro de categorias
        const selectCategoria = document.getElementById('filtroCategoria');
        const categoriasUnicas = new Set();
        
        linhas.forEach(linha => {
            if (linha.cat_transacao) {
                categoriasUnicas.add(linha.cat_transacao);
            }
        });
        
        selectCategoria.innerHTML = '<option value="">Todas as categorias</option>';
        [...categoriasUnicas].sort().forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            selectCategoria.appendChild(option);
        });
        
        // Popular filtro de origem/destino
        const selectOrigemDestino = document.getElementById('filtroOrigemDestino');
        const origensUnicas = new Set();
        
        linhas.forEach(linha => {
            if (linha.origem_destino) {
                origensUnicas.add(linha.origem_destino);
            }
        });
        
        selectOrigemDestino.innerHTML = '<option value="">Todas as origens/destinos</option>';
        [...origensUnicas].sort().forEach(origem => {
            const option = document.createElement('option');
            option.value = origem;
            option.textContent = origem;
            selectOrigemDestino.appendChild(option);
        });
        
        performanceMetrics.end(timerPopular);
    }
    
    function aplicarFiltros() {
        const timerAplicar = performanceMetrics.start('aplicarFiltros - TOTAL');
        
        const selectData = document.getElementById('filtroData');
        const selectCompetencia = document.getElementById('filtroCompetencia');
        const selectCategoria = document.getElementById('filtroCategoria');
        const selectOrigemDestino = document.getElementById('filtroOrigemDestino');
        const selectAvaliacao = document.getElementById('filtroAvaliacao');
        const selectObservacoes = document.getElementById('filtroObservacoes');
        
        const datasSelecionadas = Array.from(selectData.selectedOptions)
            .map(opt => opt.value)
            .filter(val => val !== '');
        
        const competenciasSelecionadas = Array.from(selectCompetencia.selectedOptions)
            .map(opt => opt.value)
            .filter(val => val !== '');
        
        const categoriasSelecionadas = Array.from(selectCategoria.selectedOptions)
            .map(opt => opt.value)
            .filter(val => val !== '');
        
        const origensSelecionadas = Array.from(selectOrigemDestino.selectedOptions)
            .map(opt => opt.value)
            .filter(val => val !== '');
        
        const avaliacoesSelecionadas = Array.from(selectAvaliacao.selectedOptions)
            .map(opt => opt.value)
            .filter(val => val !== '');
        
        const observacoesSelecionadas = selectObservacoes ? Array.from(selectObservacoes.selectedOptions)
            .map(opt => opt.value)
            .filter(val => val !== '') : [];
        
        const tbody = document.getElementById('tbodyConciliacao');
        const rows = tbody.getElementsByTagName('tr');
        
        linhas.forEach((linha, index) => {
            const row = rows[index];
            if (!row) return;
            
            let mostrar = true;
            
            // Filtrar por data (mês/ano)
            if (datasSelecionadas.length > 0) {
                let mesAnoLinha = '';
                if (linha.data) {
                    const partes = linha.data.split('-');
                    if (partes.length === 3) {
                        mesAnoLinha = `${partes[1]}/${partes[0]}`;
                    }
                }
                // Verificar se "Não preenchido" foi selecionado
                const naoPreenchidoData = datasSelecionadas.includes('__NAO_PREENCHIDO__');
                if (naoPreenchidoData && !linha.data) {
                    mostrar = mostrar && true;
                } else if (naoPreenchidoData) {
                    mostrar = mostrar && (datasSelecionadas.includes(mesAnoLinha) || !linha.data);
                } else {
                    mostrar = mostrar && datasSelecionadas.includes(mesAnoLinha);
                }
            }
            
            // Filtrar por competência
            if (competenciasSelecionadas.length > 0) {
                const competenciaLinha = linha.competencia ? formatarCompetenciaParaExibicao(linha.competencia) : '';
                const naoPreenchidoComp = competenciasSelecionadas.includes('__NAO_PREENCHIDO__');
                if (naoPreenchidoComp && !linha.competencia) {
                    mostrar = mostrar && true;
                } else if (naoPreenchidoComp) {
                    mostrar = mostrar && (competenciasSelecionadas.includes(competenciaLinha) || !linha.competencia);
                } else {
                    mostrar = mostrar && competenciasSelecionadas.includes(competenciaLinha);
                }
            }
            
            // Filtrar por categoria
            if (categoriasSelecionadas.length > 0) {
                const naoPreenchidoCat = categoriasSelecionadas.includes('__NAO_PREENCHIDO__');
                if (naoPreenchidoCat && (!linha.cat_transacao || linha.cat_transacao.trim() === '')) {
                    mostrar = mostrar && true;
                } else if (naoPreenchidoCat) {
                    mostrar = mostrar && (categoriasSelecionadas.includes(linha.cat_transacao) || !linha.cat_transacao || linha.cat_transacao.trim() === '');
                } else {
                    mostrar = mostrar && categoriasSelecionadas.includes(linha.cat_transacao);
                }
            }
            
            // Filtrar por origem/destino
            if (origensSelecionadas.length > 0) {
                const naoPreenchidoOrig = origensSelecionadas.includes('__NAO_PREENCHIDO__');
                if (naoPreenchidoOrig && (!linha.origem_destino || linha.origem_destino.trim() === '')) {
                    mostrar = mostrar && true;
                } else if (naoPreenchidoOrig) {
                    mostrar = mostrar && (origensSelecionadas.includes(linha.origem_destino) || !linha.origem_destino || linha.origem_destino.trim() === '');
                } else {
                    mostrar = mostrar && origensSelecionadas.includes(linha.origem_destino);
                }
            }
            
            // Filtrar por avaliação
            if (avaliacoesSelecionadas.length > 0) {
                const naoPreenchidoAval = avaliacoesSelecionadas.includes('__NAO_PREENCHIDO__');
                if (naoPreenchidoAval && (!linha.cat_avaliacao || linha.cat_avaliacao.trim() === '')) {
                    mostrar = mostrar && true;
                } else if (naoPreenchidoAval) {
                    mostrar = mostrar && (avaliacoesSelecionadas.includes(linha.cat_avaliacao) || !linha.cat_avaliacao || linha.cat_avaliacao.trim() === '');
                } else {
                    mostrar = mostrar && avaliacoesSelecionadas.includes(linha.cat_avaliacao);
                }
            }
            
            // Filtrar por observações
            if (observacoesSelecionadas.length > 0) {
                const temObservacao = linha.avaliacao_analista && linha.avaliacao_analista.trim() !== '';
                const naoPreenchido = observacoesSelecionadas.includes('__NAO_PREENCHIDO__');
                const preenchido = observacoesSelecionadas.includes('__PREENCHIDO__');
                
                if (naoPreenchido && !preenchido) {
                    mostrar = mostrar && !temObservacao;
                } else if (preenchido && !naoPreenchido) {
                    mostrar = mostrar && temObservacao;
                } else if (naoPreenchido && preenchido) {
                    // Se ambos selecionados, mostra tudo
                    mostrar = mostrar && true;
                }
            }
            
            row.style.display = mostrar ? '' : 'none';
        });
        
        performanceMetrics.end(timerAplicar);
    }
    
    function atualizarDatalistOrigemDestino() {
        const timerDatalist = performanceMetrics.start('atualizarDatalistOrigemDestino');
        
        // Atualizar lista de origens/destinos únicos
        linhas.forEach(linha => {
            if (linha.origem_destino) {
                origensDestinosUnicos.add(linha.origem_destino);
            }
        });
        
        // Atualizar datalist
        const datalist = document.getElementById('datalistOrigemDestino');
        datalist.innerHTML = '';
        
        [...origensDestinosUnicos].sort().forEach(origem => {
            const option = document.createElement('option');
            option.value = origem;
            datalist.appendChild(option);
        });
        
        performanceMetrics.end(timerDatalist);
    }

    function atualizarDatalistObservacoes() {
        const timerDatalist = performanceMetrics.start('atualizarDatalistObservacoes');
        
        // Atualizar lista de observações únicas
        linhas.forEach(linha => {
            if (linha.avaliacao_analista && linha.avaliacao_analista.trim() !== '') {
                observacoesUnicas.add(linha.avaliacao_analista.trim());
            }
        });
        
        // Atualizar datalist
        const datalist = document.getElementById('datalistObservacoes');
        datalist.innerHTML = '';
        
        [...observacoesUnicas].sort().forEach(obs => {
            const option = document.createElement('option');
            option.value = obs;
            datalist.appendChild(option);
        });
        
        performanceMetrics.end(timerDatalist);
    }
    
    function excluirLinhasPorIntervalo() {
        const input = document.getElementById('inputExcluirLinhas').value.trim();
        
        if (!input) {
            alert('Digite o intervalo ou índices para excluir.\nExemplos:\n- Intervalo: 114-120\n- Múltiplos: 5,10,15,20\n- Combinado: 1-5,10,15-20');
            return;
        }
        
        const indicesParaExcluir = new Set();
        
        // Parse do input (aceita intervalos e valores individuais)
        const partes = input.split(',').map(p => p.trim());
        
        for (const parte of partes) {
            if (parte.includes('-')) {
                // Intervalo: 114-120
                const [inicio, fim] = parte.split('-').map(n => parseInt(n.trim()));
                
                if (isNaN(inicio) || isNaN(fim)) {
                    alert(`Intervalo inválido: ${parte}`);
                    return;
                }
                
                if (inicio > fim) {
                    alert(`Intervalo inválido: ${parte} (início maior que fim)`);
                    return;
                }
                
                for (let i = inicio; i <= fim; i++) {
                    indicesParaExcluir.add(i);
                }
            } else {
                // Valor individual: 5
                const indice = parseInt(parte);
                
                if (isNaN(indice)) {
                    alert(`Valor inválido: ${parte}`);
                    return;
                }
                
                indicesParaExcluir.add(indice);
            }
        }
        
        // Verificar se há índices para excluir
        if (indicesParaExcluir.size === 0) {
            alert('Nenhum índice válido para excluir');
            return;
        }
        
        // Salvar estado antes de modificar
        salvarEstadoNoHistorico();
        
        // Filtrar linhas pelo índice
        const linhasOriginais = linhas.length;
        linhas = linhas.filter(linha => !indicesParaExcluir.has(linha.indice));
        
        const linhasExcluidas = linhasOriginais - linhas.length;
        
        if (linhasExcluidas === 0) {
            alert('Nenhuma linha foi excluída. Verifique se os índices existem.');
            return;
        }
        
        // Perguntar confirmação
        if (!confirm(`${linhasExcluidas} linha(s) serão excluídas. Confirmar?`)) {
            // Desfazer via histórico
            desfazerAlteracao();
            return;
        }
        
        // Recalcular índices
        recalcularIndices();
        
        // Re-renderizar
        renderizarTabela();
        
        // Limpar input
        document.getElementById('inputExcluirLinhas').value = '';
        
        document.getElementById('btnSalvar').style.display = 'block';
        agendarAutosave();
        
        alert(`✓ ${linhasExcluidas} linha(s) excluída(s) com sucesso!`);
    }
    
    function salvarEstadoNoHistorico() {
        // Salvar snapshot do estado atual
        const snapshot = {
            linhas: JSON.parse(JSON.stringify(linhas)),
            notasFiscais: JSON.parse(JSON.stringify(notasFiscais)),
            timestamp: Date.now()
        };
        
        historicoAlteracoes.push(snapshot);
        
        // Limitar histórico a MAX_HISTORICO estados
        if (historicoAlteracoes.length > MAX_HISTORICO) {
            historicoAlteracoes.shift();
        }
        
        // Mostrar botão Undo
        const btnUndo = document.getElementById('btnUndo');
        if (btnUndo) {
            btnUndo.style.display = '';
            btnUndo.title = `Desfazer (${historicoAlteracoes.length} estado(s) salvos)`;
        }
    }
    
    function desfazerAlteracao() {
        if (historicoAlteracoes.length === 0) {
            alert('Nenhuma alteração para desfazer');
            return;
        }
        
        // Restaurar último estado
        const estadoAnterior = historicoAlteracoes.pop();
        
        linhas = estadoAnterior.linhas;
        notasFiscais = estadoAnterior.notasFiscais;
        
        renderizarTabela();
        
        // Atualizar botão Undo
        const btnUndo = document.getElementById('btnUndo');
        if (btnUndo) {
            if (historicoAlteracoes.length === 0) {
                btnUndo.style.display = 'none';
            } else {
                btnUndo.title = `Desfazer (${historicoAlteracoes.length} estado(s) salvos)`;
            }
        }
        
        document.getElementById('btnSalvar').style.display = 'block';
    }

    function filtrarPorData() {
        const dataFiltro = prompt('Digite a data para filtrar (dd/mm/aaaa) ou deixe vazio para ver todas:');
        
        if (dataFiltro === null) return; // Cancelou
        
        const tbody = document.getElementById('tbodyConciliacao');
        const rows = tbody.getElementsByTagName('tr');
        
        if (!dataFiltro || dataFiltro.trim() === '') {
            // Mostrar todas
            for (let row of rows) {
                row.style.display = '';
            }
            return;
        }
        
        // Converter dd/mm/aaaa para aaaa-mm-dd
        const partes = dataFiltro.split('/');
        if (partes.length !== 3) {
            alert('Formato inválido! Use dd/mm/aaaa');
            return;
        }
        
        const dataFormatada = `${partes[2]}-${partes[1].padStart(2, '0')}-${partes[0].padStart(2, '0')}`;
        
        // Filtrar linhas
        linhas.forEach((linha, index) => {
            const row = rows[index];
            if (row) {
                row.style.display = linha.data === dataFormatada ? '' : 'none';
            }
        });
    }
    
    function filtrarPorCategoria() {
        const categoriaFiltro = prompt('Digite a categoria para filtrar (ou parte dela) ou deixe vazio para ver todas:');
        
        if (categoriaFiltro === null) return; // Cancelou
        
        const tbody = document.getElementById('tbodyConciliacao');
        const rows = tbody.getElementsByTagName('tr');
        
        if (!categoriaFiltro || categoriaFiltro.trim() === '') {
            // Mostrar todas
            for (let row of rows) {
                row.style.display = '';
            }
            return;
        }
        
        const filtroLower = categoriaFiltro.toLowerCase();
        
        // Filtrar linhas (ALIKE - busca parcial case-insensitive)
        linhas.forEach((linha, index) => {
            const row = rows[index];
            if (row) {
                const categoria = linha.cat_transacao || '';
                const match = categoria.toLowerCase().includes(filtroLower);
                row.style.display = match ? '' : 'none';
            }
        });
    }
    
    function limparFiltros() {
        // Limpar seleções dos filtros
        document.getElementById('filtroData').selectedIndex = -1;
        document.getElementById('filtroCompetencia').selectedIndex = -1;
        document.getElementById('filtroCategoria').selectedIndex = -1;
        document.getElementById('filtroOrigemDestino').selectedIndex = -1;
        
        const tbody = document.getElementById('tbodyConciliacao');
        const rows = tbody.getElementsByTagName('tr');
        
        // Mostrar todas as linhas
        for (let row of rows) {
            row.style.display = '';
        }
    }

    function moverLinha(index, direcao) {
        if (index + direcao < 0 || index + direcao >= linhas.length) return;
        
        // Trocar posições
        const temp = linhas[index];
        linhas[index] = linhas[index + direcao];
        linhas[index + direcao] = temp;
        
        // Recalcular índices
        recalcularIndices();
        renderizarTabela();
        agendarAutosave();
    }

    function excluirLinha(index) {
        if (!confirm('Deseja realmente excluir esta linha?')) return;
        
        linhas.splice(index, 1);
        recalcularIndices();
        renderizarTabela();
        agendarAutosave();
    }

    function recalcularIndices() {
        linhas.forEach((linha, i) => {
            linha.indice = i + 1;
        });
        proximoIndice = linhas.length + 1;
    }

    function limparTabela() {
        if (!confirm('Tem certeza que deseja limpar toda a tabela? Esta ação não pode ser desfeita.')) {
            return;
        }
        
        linhas = [];
        renderizarTabela();
        document.getElementById('btnSalvar').style.display = 'none';
    }

    function exportarCSV() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) {
            alert('Selecione um termo antes de exportar.');
            return;
        }
        
        if (linhas.length === 0) {
            alert('Não há dados para exportar.');
            return;
        }
        
        // Redirecionar para a rota de exportação
        window.location.href = `/conc_bancaria/api/exportar-csv?numero_termo=${encodeURIComponent(numeroTermo)}`;
    }
    
    function selecionarTodasColunas() {
        document.querySelectorAll('#modalExportarPDF input[type="checkbox"]').forEach(cb => {
            cb.checked = true;
        });
    }
    
    function desmarcarTodasColunas() {
        document.querySelectorAll('#modalExportarPDF input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
        });
    }
    
    function expandirFiltros() {
        // Sincronizar valores dos filtros compactos para os expandidos
        sincronizarFiltro('filtroDataExpandido', 'filtroData');
        sincronizarFiltro('filtroCompetenciaExpandido', 'filtroCompetencia');
        sincronizarFiltro('filtroCategoriaExpandido', 'filtroCategoria');
        sincronizarFiltro('filtroOrigemDestinoExpandido', 'filtroOrigemDestino');
        sincronizarFiltro('filtroAvaliacaoExpandido', 'filtroAvaliacao');
        
        // Abrir modal
        const modal = new bootstrap.Modal(document.getElementById('modalFiltrosExpandidos'));
        modal.show();
    }
    
    function sincronizarFiltro(destino, origem) {
        const selectOrigem = document.getElementById(origem);
        const selectDestino = document.getElementById(destino);
        
        if (!selectOrigem || !selectDestino) return;
        
        // Copiar opções do origem para destino (se ainda não existirem)
        const opcoesOrigem = Array.from(selectOrigem.options);
        const valoresDestino = Array.from(selectDestino.options).map(opt => opt.value);
        
        opcoesOrigem.forEach(opcao => {
            if (!valoresDestino.includes(opcao.value)) {
                const novaOpcao = opcao.cloneNode(true);
                selectDestino.appendChild(novaOpcao);
            }
        });
        
        // Sincronizar seleções
        const selecionadasOrigem = Array.from(selectOrigem.selectedOptions).map(opt => opt.value);
        Array.from(selectDestino.options).forEach(opt => {
            opt.selected = selecionadasOrigem.includes(opt.value);
        });
        
        // Aplicar filtros após sincronização
        aplicarFiltros();
    }
    
    function limparFiltrosExpandidos() {
        // Limpar todos os filtros expandidos
        document.getElementById('filtroDataExpandido').selectedIndex = -1;
        document.getElementById('filtroCompetenciaExpandido').selectedIndex = -1;
        document.getElementById('filtroCategoriaExpandido').selectedIndex = -1;
        document.getElementById('filtroOrigemDestinoExpandido').selectedIndex = -1;
        document.getElementById('filtroAvaliacaoExpandido').selectedIndex = -1;
        
        // Sincronizar com filtros compactos
        sincronizarFiltro('filtroData', 'filtroDataExpandido');
        sincronizarFiltro('filtroCompetencia', 'filtroCompetenciaExpandido');
        sincronizarFiltro('filtroCategoria', 'filtroCategoriaExpandido');
        sincronizarFiltro('filtroOrigemDestino', 'filtroOrigemDestinoExpandido');
        sincronizarFiltro('filtroAvaliacao', 'filtroAvaliacaoExpandido');
    }
    
    function desmarcarTodasColunas() {
        document.querySelectorAll('#modalExportarPDF input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
        });
    }
    
    function exportarPDF() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) {
            alert('Selecione um termo antes de exportar.');
            return;
        }
        
        if (linhas.length === 0) {
            alert('Não há dados para exportar.');
            return;
        }
        
        // Coletar colunas selecionadas
        const colunasSelecionadas = [];
        document.querySelectorAll('#modalExportarPDF input[type="checkbox"]:checked').forEach(cb => {
            colunasSelecionadas.push(cb.value);
        });
        
        if (colunasSelecionadas.length === 0) {
            alert('Selecione pelo menos uma coluna para exportar.');
            return;
        }
        
        // Criar query string com colunas selecionadas
        const colunasParam = colunasSelecionadas.join(',');
        
        // Fechar modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('modalExportarPDF'));
        modal.hide();
        
        // Redirecionar para a rota de exportação PDF
        window.location.href = `/conc_bancaria/api/exportar-pdf?numero_termo=${encodeURIComponent(numeroTermo)}&colunas=${encodeURIComponent(colunasParam)}`;
    }
    
    // DESABILITADO: processarMesclagensAutomaticas
    // A validação de composição agora é baseada apenas em data/valor, não em mesclado_com
    /*
    function processarMesclagensAutomaticas() {
        ...código comentado...
    }
    */
    
    function baixarModelo() {
        window.location.href = '/conc_bancaria/api/modelo-importacao';
    }

    function atualizarHrefRendimentos() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (numeroTermo) {
            document.getElementById('btnRendimentos').href = `/conc_rendimentos/?termo=${encodeURIComponent(numeroTermo)}`;
        }
    }

    function atualizarHrefContrapartida() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (numeroTermo) {
            document.getElementById('btnContrapartida').href = `/conc_contrapartida/?termo=${encodeURIComponent(numeroTermo)}`;
        }
    }

    async function atualizarHrefOCR() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        
        // Salvar termo na session antes de atualizar href
        if (numeroTermo) {
            try {
                await fetch('/conc_bancaria/api/salvar-termo-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ numero_termo: numeroTermo })
                });
            } catch (error) {
                console.error('Erro ao salvar termo na sessão:', error);
            }
        }
        // Href já está definido como /ocr_testes/ no HTML
    }

    async function atualizarHrefRelatorio() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (numeroTermo) {
            document.getElementById('btnRelatorio').href = `/conc_relatorio/?termo=${encodeURIComponent(numeroTermo)}`;
        }
    }

    function abrirRendimentos(event) {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) {
            event.preventDefault();
            alert('Selecione um termo primeiro!');
            return false;
        }
        // Atualizar href antes de navegar
        const url = `/conc_rendimentos/?termo=${encodeURIComponent(numeroTermo)}`;
        document.getElementById('btnRendimentos').href = url;
        
        // Se for click esquerdo sem modificadores, redirecionar
        if (event.button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey) {
            event.preventDefault();
            window.location.href = url;
        }
        // Click do meio ou Ctrl+Click: deixar o navegador abrir em nova aba
        return true;
    }

    function abrirContrapartida(event) {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) {
            event.preventDefault();
            alert('Selecione um termo primeiro!');
            return false;
        }
        // Atualizar href antes de navegar
        const url = `/conc_contrapartida/?termo=${encodeURIComponent(numeroTermo)}`;
        document.getElementById('btnContrapartida').href = url;
        
        // Se for click esquerdo sem modificadores, redirecionar
        if (event.button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey) {
            event.preventDefault();
            window.location.href = url;
        }
        // Click do meio ou Ctrl+Click: deixar o navegador abrir em nova aba
        return true;
    }

    function abrirRelatorio(event) {
        const numeroTermo = document.getElementById('numeroTermo').value;
        if (!numeroTermo) {
            event.preventDefault();
            alert('Selecione um termo primeiro!');
            return false;
        }
        // Atualizar href antes de navegar
        const url = `/conc_relatorio/?termo=${encodeURIComponent(numeroTermo)}`;
        document.getElementById('btnRelatorio').href = url;
        
        // Se for click esquerdo sem modificadores, redirecionar
        if (event.button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey) {
            event.preventDefault();
            window.location.href = url;
        }
        // Click do meio ou Ctrl+Click: deixar o navegador abrir em nova aba
        return true;
    }

    async function abrirOCR(event) {
        const numeroTermo = document.getElementById('numeroTermo').value;
        
        // Salvar termo na session antes de ir para OCR
        if (numeroTermo) {
            try {
                await fetch('/conc_bancaria/api/salvar-termo-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ numero_termo: numeroTermo })
                });
            } catch (error) {
                console.error('Erro ao salvar termo na sessão:', error);
            }
        }
        
        const url = '/ocr_testes/';
        
        // Se for click esquerdo sem modificadores, redirecionar
        if (event.button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey) {
            event.preventDefault();
            window.location.href = url;
        }
        // Click do meio ou Ctrl+Click: deixar o navegador abrir em nova aba
        return true;
    }

    async function verificarContrapartida(numeroTermo) {
        try {
            const response = await fetch(`/conc_contrapartida/api/verificar-contrapartida/${encodeURIComponent(numeroTermo)}`);
            const result = await response.json();
            
            if (response.ok && result.tem_contrapartida) {
                document.getElementById('btnContrapartida').style.display = 'inline-block';
            } else {
                document.getElementById('btnContrapartida').style.display = 'none';
            }
        } catch (error) {
            console.error('Erro ao verificar contrapartida:', error);
            document.getElementById('btnContrapartida').style.display = 'none';
        }
    }

    async function salvarConciliacao() {
        const numeroTermo = document.getElementById('numeroTermo').value;
        const bancoExtrato = document.getElementById('bancoExtrato').value;
        
        if (!numeroTermo) {
            alert('Selecione um número de termo');
            return;
        }

        // Filtrar linhas com pelo menos um campo preenchido
        const linhasParaSalvar = linhas.filter(linha => {
            return linha.data || linha.credito || linha.debito || linha.discriminacao;
        }).map(linha => {
            // Auto-preencher competência se estiver vazia mas tiver data
            // EXCETO se o usuário deletou manualmente
            let competencia = linha.competencia;
            if (!competencia && linha.data && !linha._competencia_deletada) {
                competencia = calcularCompetenciaAutomatica(linha.data);
            }
            
            // Auto-preencher origem_destino se estiver vazia mas tiver categoria
            let origemDestino = linha.origem_destino;
            if (!origemDestino && linha.cat_transacao) {
                const categoria = categoriasAnalise.find(cat => cat.categoria_extra === linha.cat_transacao);
                if (categoria && categoria.correspondente) {
                    origemDestino = categoria.correspondente;
                    
                    // Se o correspondente for "Banco", substituir pelo banco atual do termo
                    if (origemDestino === 'Banco' && bancoAtual) {
                        origemDestino = bancoAtual;
                    }
                }
            }
            
            // Auto-classificar avaliação baseado em regras (prioridade: categoria > origem/destino)
            let avaliacaoAuto = linha.cat_avaliacao;
            
            // Regra prioritária: Categoria de Transação
            if (!avaliacaoAuto && linha.cat_transacao && regrasAvaliacao.glosar.includes(linha.cat_transacao)) {
                avaliacaoAuto = 'Glosar';
            }
            
            // Regra secundária: Origem/Destino
            if (!avaliacaoAuto && origemDestino) {
                const origemNormalizada = origemDestino.toLowerCase().trim();
                if (regrasAvaliacao.avaliado.includes(origemNormalizada)) {
                    avaliacaoAuto = 'Avaliado';
                }
            }
            
            // Auto-preencher composição se estiver vazia
            let discriminacao = linha.discriminacao;
            if (!discriminacao && (linha.credito || linha.debito)) {
                discriminacao = linha.credito || linha.debito;
            }
            
            return {
                id: linha.id,
                indice: linha.indice,
                data: linha.data,
                credito: linha.credito,
                debito: linha.debito,
                discriminacao: discriminacao,
                cat_transacao: linha.cat_transacao,
                competencia: competencia,
                origem_destino: origemDestino,
                cat_avaliacao: avaliacaoAuto,
                avaliacao_analista: linha.avaliacao_analista,
                mesclado_com: linha.mesclado_com || []
            };
        });

        if (linhasParaSalvar.length === 0) {
            if (!confirm('Não há dados para salvar. Deseja salvar mesmo assim (limpar todos os dados existentes)?')) {
                return;
            }
        }

        try {
            document.getElementById('btnSalvar').disabled = true;
            document.getElementById('btnSalvar').innerHTML = '<i class="bi bi-hourglass-split me-2"></i>Salvando...';

            // Salvar extrato
            const response = await fetch('/conc_bancaria/api/extrato', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    numero_termo: numeroTermo,
                    linhas: linhasParaSalvar,
                    modo_completo: limiteAtual === 'todas'  // Só deleta se carregou todas
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.erro || 'Erro ao salvar extrato');
            }

            // Salvar banco (se preenchido)
            if (bancoExtrato) {
                const bancResponse = await fetch('/conc_bancaria/api/banco', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        numero_termo: numeroTermo,
                        banco_extrato: bancoExtrato
                    })
                });

                if (!bancResponse.ok) {
                    console.warn('Aviso: Não foi possível salvar o banco');
                }
            }

            const resultado = await response.json();
            // Não mostrar mensagem de sucesso - apenas erros
            
            // Salvar Notas Fiscais (se seção ativada)
            if (secaoNotasFiscaisAtiva && Object.keys(notasFiscais).length > 0) {
                const notasParaSalvar = Object.entries(notasFiscais)
                    .filter(([concExtratoId, nf]) => nf.numero_nota) // Só salvar se tiver número da nota
                    .map(([concExtratoId, nf]) => ({
                        conc_extrato_id: parseInt(concExtratoId),
                        numero_nota: nf.numero_nota,
                        chave_acesso: nf.chave_acesso || null,
                        cnpj_nota: nf.cnpj_nota || null
                    }));
                
                if (notasParaSalvar.length > 0) {
                    const nfResponse = await fetch('/conc_bancaria/api/notas-fiscais', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            numero_termo: numeroTermo,
                            notas: notasParaSalvar
                        })
                    });
                    
                    if (!nfResponse.ok) {
                        console.warn('Aviso: Não foi possível salvar notas fiscais');
                    }
                }
            }
            
            // Salvar documentos de análise se seção estiver ativa
            if (secaoDocumentosAtiva) {
                // Incluir TODAS as linhas salvas (com ID), não apenas as editadas
                const documentosParaSalvar = linhas
                    .filter(linha => linha.id) // Apenas linhas já salvas no banco
                    .map(linha => {
                        const categoria = linha.cat_transacao || '';
                        const rubrica = categoriasRubricas[categoria] || '';
                        const naoAplicavelGeral = categoriasAplicabilidade[categoria] === true;
                        
                        // Regras específicas por rubrica
                        const naoAplicavelForaMunicipio = naoAplicavelGeral || 
                                                          rubrica === 'Pessoal' || 
                                                          rubrica === 'Administrativas';
                        
                        const naoAplicavelContratos = naoAplicavelGeral || 
                                                      ['Pessoal', 'Materiais', 'Implantação', 'Imobilizado'].includes(rubrica);
                        
                        // Buscar documento existente no objeto indexado
                        const doc = documentosAnalise[linha.id] || {};
                        
                        // SISTEMA DE DROPDOWNS: Enviar valores de texto diretamente
                        // Se campo não aplicável → enviar string vazia (será ignorado no backend)
                        // Se campo aplicável → enviar valor selecionado ou vazio se não selecionado
                        
                        return {
                            conc_extrato_id: linha.id,
                            avaliacao_guia: naoAplicavelGeral ? '' : (doc.avaliacao_guia || ''),
                            avaliacao_comprovante: naoAplicavelGeral ? '' : (doc.avaliacao_comprovante || ''),
                            avaliacao_contratos: naoAplicavelContratos ? '' : (doc.avaliacao_contratos || ''),
                            avaliacao_fora_municipio: naoAplicavelForaMunicipio ? '' : (doc.avaliacao_fora_municipio || '')
                        };
                    });
                
                if (documentosParaSalvar.length > 0) {
                    const docResponse = await fetch('/conc_bancaria/api/documentos-analise', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            numero_termo: numeroTermo,
                            documentos: documentosParaSalvar
                        })
                    });
                    
                    if (!docResponse.ok) {
                        console.warn('Aviso: Não foi possível salvar documentos de análise');
                    }
                }
            }
            
            // Limpar cache após salvar com sucesso
            limparCache();
            
            // Atualizar IDs das linhas que foram inseridas (novas linhas sem ID)
            // O backend retorna os IDs das linhas inseridas
            if (resultado.ids_inseridos && resultado.ids_inseridos.length > 0) {
                let indexId = 0;
                linhas.forEach(linha => {
                    if (!linha.id && indexId < resultado.ids_inseridos.length) {
                        linha.id = resultado.ids_inseridos[indexId];
                        indexId++;
                    }
                });
            }
            
            // Recarregar apenas dados auxiliares (Notas Fiscais e Documentos) se necessário
            // NÃO recarregar extrato completo - os dados em memória já estão corretos
            if (secaoNotasFiscaisAtiva) {
                await carregarNotasFiscais();
            }
            if (secaoDocumentosAtiva) {
                await carregarDocumentosAnalise();
            }
            
            // Re-renderizar tabela para atualizar IDs e estado visual
            renderizarTabela();

        } catch (error) {
            console.error('Erro ao salvar:', error);
            alert('Erro ao salvar conciliação: ' + error.message);
        } finally {
            document.getElementById('btnSalvar').disabled = false;
            document.getElementById('btnSalvar').innerHTML = '<i class="bi bi-save me-2"></i>Salvar Conciliação';
        }
    }

    // Função para ir à última linha da tabela
    function irParaUltimaLinha() {
        const tbody = document.getElementById('tbodyConciliacao');
        if (tbody && tbody.lastElementChild) {
            tbody.lastElementChild.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }
    }
    
    // FUNÇÃO: Atualizar guias automaticamente
    async function atualizarGuiasAutomaticamente() {
        // PASSO 1: Simular as alterações sem aplicá-las
        let contadorGuias = 0;
        let linhasParaAlterar = []; // Lista para preview
        
        // Percorrer todas as linhas para gerar preview
        linhas.forEach((linha, index) => {
            let linhaAlterada = false;
            let alteracoes = [];
            
            // === VERIFICAÇÃO DE GUIAS ===
            // Requisitos para atualizar:
            // 1. Origem/Destino preenchido
            // 2. Categoria (cat_transacao) preenchida
            // 3. Composição (discriminacao) preenchida
            // 4. Linha tem ID (está salva no banco)
            // 5. Guia está como "Não apresentada" ou vazia/Selecione
            
            const temOrigemDestino = linha.origem_destino && linha.origem_destino.trim() !== '';
            const temCategoria = linha.cat_transacao && linha.cat_transacao.trim() !== '';
            const ehDebito = linha.debito && linha.debito > 0;
            const temComposicao = ehDebito && linha.discriminacao && linha.discriminacao > 0;
            
            // DEBUG: Log detalhado para entender o problema
            if (temOrigemDestino && temCategoria && linha.id) {
                console.log(`[DEBUG PREVIEW] Linha ${linha.indice}:`, {
                    origem: linha.origem_destino,
                    categoria: linha.cat_transacao,
                    credito: linha.credito,
                    debito: linha.debito,
                    discriminacao: linha.discriminacao,
                    ehDebito: ehDebito,
                    temComposicao: temComposicao,
                    vai_atualizar_guia: temComposicao
                });
            }
            
            if (temOrigemDestino && temCategoria && temComposicao && linha.id) {
                const categoriaNaoAplicavel = categoriasAplicabilidade[linha.cat_transacao] === true;
                
                // Só atualizar se categoria NÃO é "Não aplicável"
                if (!categoriaNaoAplicavel) {
                    const doc = documentosAnalise[linha.id];
                    
                    // Verificar se guia está vazia, "Não apresentada" ou não definida
                    if (doc && (
                        !doc.avaliacao_guia || 
                        doc.avaliacao_guia === '' || 
                        doc.avaliacao_guia === 'Não apresentada'
                    )) {
                        contadorGuias++;
                        linhaAlterada = true;
                        alteracoes.push('Guia → "Guia apresentada"');
                    }
                }
            }
            
            // === COMPETÊNCIAS E GLOSAR DESATIVADOS ===
            // (código mantido comentado para referência futura)
            /*
            // === VERIFICAÇÃO DE COMPETÊNCIAS ===
            if (!linha.competencia && linha.data && !linha._competencia_deletada) {
                const competenciaAuto = calcularCompetenciaAutomatica(linha.data);
                if (competenciaAuto) {
                    contadorCompetencias++;
                    linhaAlterada = true;
                    alteracoes.push(`Competência → ${competenciaAuto}`);
                }
            }
            
            // === VERIFICAÇÃO DE GLOSAR ===
            const categoriaDebito = linha.cat_transacao === 'Débitos Indevidos' || linha.cat_transacao === 'Débitos não identificados';
            if (categoriaDebito) {
                const doc = documentosAnalise[linha.id];
                
                if (doc && (!doc.avaliacao_analista || doc.avaliacao_analista.trim() === '' || doc.avaliacao_analista === 'Avaliado')) {
                    contadorGlosar++;
                    linhaAlterada = true;
                    alteracoes.push('Avaliação → "Glosar"');
                }
            }
            */
            
            // Adicionar à lista se houve alguma alteração
            if (linhaAlterada) {
                linhasParaAlterar.push({
                    indice: linha.indice,
                    data: linha.data ? formatarDataParaExibicao(linha.data) : '',
                    origem_destino: linha.origem_destino || '',
                    categoria: linha.cat_transacao || '',
                    composicao: formatarMoeda(linha.discriminacao),
                    alteracoes: alteracoes.join(' | ')
                });
            }
        });
        
        // PASSO 2: Mostrar preview e solicitar confirmação
        if (contadorGuias === 0) {
            alert('❌ Nenhuma alteração será realizada.\n\nMotivos possíveis:\n• Guias já estão preenchidas\n• Linhas não possuem Origem/Destino, Categoria e Composição preenchidos simultaneamente\n• Categoria está marcada como "Não aplicável"\n• Linhas não foram salvas ainda (sem ID)');
            return;
        }
        
        // Construir mensagem de preview
        let mensagemPreview = '📋 PREVIEW DAS ALTERAÇÕES A SEREM REALIZADAS\n';
        mensagemPreview += '═'.repeat(60) + '\n\n';
        mensagemPreview += '📊 RESUMO:\n';
        mensagemPreview += `   🎫 ${contadorGuias} guia(s) serão atualizadas para "Guia apresentada"\n`;
        
        mensagemPreview += '\n📝 DETALHES DAS ALTERAÇÕES:\n';
        mensagemPreview += '═'.repeat(60) + '\n\n';
        
        linhasParaAlterar.forEach((linha, idx) => {
            if (idx < 15) { // Limitar a 15 linhas no preview
                mensagemPreview += `${idx + 1}. Índice ${linha.indice}`;
                if (linha.data) mensagemPreview += ` | ${linha.data}`;
                mensagemPreview += '\n';
                
                if (linha.origem_destino) {
                    mensagemPreview += `   Origem/Destino: ${linha.origem_destino}\n`;
                }
                if (linha.categoria) {
                    mensagemPreview += `   Categoria: ${linha.categoria}\n`;
                }
                if (linha.composicao) {
                    mensagemPreview += `   Composição: ${linha.composicao}\n`;
                }
                mensagemPreview += `   ✏️ ${linha.alteracoes}\n\n`;
            }
        });
        
        if (linhasParaAlterar.length > 15) {
            mensagemPreview += `... e mais ${linhasParaAlterar.length - 15} linha(s).\n\n`;
        }
        
        mensagemPreview += '═'.repeat(60) + '\n';
        mensagemPreview += '⚠️ As alterações NÃO foram aplicadas ainda.\n';
        mensagemPreview += 'Deseja APLICAR estas alterações?\n\n';
        mensagemPreview += 'Clique OK para CONFIRMAR ou CANCELAR para abortar.';
        
        // Solicitar confirmação
        if (!confirm(mensagemPreview)) {
            alert('❌ Operação cancelada. Nenhuma alteração foi realizada.');
            return;
        }
        
        // PASSO 3: Aplicar as alterações
        let contadorGuiasAplicadas = 0;
        
        linhas.forEach((linha, index) => {
            // === ATUALIZAÇÃO DE GUIAS ===
            const temOrigemDestino = linha.origem_destino && linha.origem_destino.trim() !== '';
            const temCategoria = linha.cat_transacao && linha.cat_transacao.trim() !== '';
            const ehDebito = linha.debito && linha.debito > 0;
            const temComposicao = ehDebito && linha.discriminacao && linha.discriminacao > 0;
            
            // DEBUG: Log detalhado para entender o problema na aplicação
            if (temOrigemDestino && temCategoria && linha.id) {
                console.log(`[DEBUG APLICACAO] Linha ${linha.indice}:`, {
                    origem: linha.origem_destino,
                    categoria: linha.cat_transacao,
                    credito: linha.credito,
                    debito: linha.debito,
                    discriminacao: linha.discriminacao,
                    ehDebito: ehDebito,
                    temComposicao: temComposicao,
                    vai_atualizar_guia: temComposicao
                });
            }
            
            if (temOrigemDestino && temCategoria && temComposicao && linha.id) {
                const categoriaNaoAplicavel = categoriasAplicabilidade[linha.cat_transacao] === true;
                
                if (!categoriaNaoAplicavel) {
                    const doc = documentosAnalise[linha.id];
                    
                    if (doc && (
                        !doc.avaliacao_guia || 
                        doc.avaliacao_guia === '' || 
                        doc.avaliacao_guia === 'Não apresentada'
                    )) {
                        doc.avaliacao_guia = 'Guia apresentada';
                        contadorGuiasAplicadas++;
                    }
                }
            }
            
            // === COMPETÊNCIAS E GLOSAR DESATIVADOS ===
            /*
            // === ATUALIZAÇÃO DE COMPETÊNCIAS ===
            if (!linha.competencia && linha.data && !linha._competencia_deletada) {
                const competenciaAuto = calcularCompetenciaAutomatica(linha.data);
                if (competenciaAuto) {
                    linha.competencia = competenciaAuto;
                    contadorCompetenciasAplicadas++;
                }
            }
            
            // === ATUALIZAÇÃO DE GLOSAR ===
            const categoriaDebito = linha.cat_transacao === 'Débitos Indevidos' || linha.cat_transacao === 'Débitos não identificados';
            if (categoriaDebito) {
                const doc = documentosAnalise[linha.id];
                
                if (doc && (!doc.avaliacao_analista || doc.avaliacao_analista.trim() === '' || doc.avaliacao_analista === 'Avaliado')) {
                    doc.avaliacao_analista = 'Glosar';
                    contadorGlosarAplicadas++;
                }
            }
            */
        });
        
        if (contadorGuiasAplicadas === 0) {
            alert('❌ Nenhuma alteração foi aplicada (possível erro interno).');
            return;
        }
        
        // Re-renderizar tabela
        renderizarTabela();
        
        // Construir mensagem de conclusão
        let mensagemFinal = '✅ ALTERAÇÕES APLICADAS COM SUCESSO!\n';
        mensagemFinal += '═'.repeat(60) + '\n\n';
        mensagemFinal += `🎫 ${contadorGuiasAplicadas} guia(s) atualizada(s) para "Guia apresentada"\n`;
        mensagemFinal += '\n═'.repeat(60) + '\n';
        mensagemFinal += '⚠️ ATENÇÃO: As alterações NÃO foram salvas ainda!\n';
        mensagemFinal += 'Revise a tabela e clique em SALVAR para confirmar.';
        
        alert(mensagemFinal);
    }
</script>

<!-- Indicador de Autosave Fixo -->
<small id="autosaveStatus">💾 Salvo em cache</small>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
